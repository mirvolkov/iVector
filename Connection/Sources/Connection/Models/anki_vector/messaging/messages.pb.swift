// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: anki_vector/messaging/messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2018 Anki, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License in the file LICENSE.txt or at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// External interface for robot <-> app and robot <-> sdk communication

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Anki_Vector_ExternalInterface_RobotStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case none // = 0
  case isMoving // = 1
  case isCarryingBlock // = 2
  case isPickingOrPlacing // = 4
  case isPickedUp // = 8
  case isButtonPressed // = 16
  case isFalling // = 32
  case isAnimating // = 64
  case isPathing // = 128
  case liftInPos // = 256
  case headInPos // = 512
  case calmPowerMode // = 1024
  case isOnCharger // = 4096
  case isCharging // = 8192
  case cliffDetected // = 16384
  case areWheelsMoving // = 32768
  case isBeingHeld // = 65536
  case isMotionDetected // = 131072
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .isMoving
    case 2: self = .isCarryingBlock
    case 4: self = .isPickingOrPlacing
    case 8: self = .isPickedUp
    case 16: self = .isButtonPressed
    case 32: self = .isFalling
    case 64: self = .isAnimating
    case 128: self = .isPathing
    case 256: self = .liftInPos
    case 512: self = .headInPos
    case 1024: self = .calmPowerMode
    case 4096: self = .isOnCharger
    case 8192: self = .isCharging
    case 16384: self = .cliffDetected
    case 32768: self = .areWheelsMoving
    case 65536: self = .isBeingHeld
    case 131072: self = .isMotionDetected
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .isMoving: return 1
    case .isCarryingBlock: return 2
    case .isPickingOrPlacing: return 4
    case .isPickedUp: return 8
    case .isButtonPressed: return 16
    case .isFalling: return 32
    case .isAnimating: return 64
    case .isPathing: return 128
    case .liftInPos: return 256
    case .headInPos: return 512
    case .calmPowerMode: return 1024
    case .isOnCharger: return 4096
    case .isCharging: return 8192
    case .cliffDetected: return 16384
    case .areWheelsMoving: return 32768
    case .isBeingHeld: return 65536
    case .isMotionDetected: return 131072
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_RobotStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_RobotStatus] = [
    .none,
    .isMoving,
    .isCarryingBlock,
    .isPickingOrPlacing,
    .isPickedUp,
    .isButtonPressed,
    .isFalling,
    .isAnimating,
    .isPathing,
    .liftInPos,
    .headInPos,
    .calmPowerMode,
    .isOnCharger,
    .isCharging,
    .cliffDetected,
    .areWheelsMoving,
    .isBeingHeld,
    .isMotionDetected,
  ]
}

#endif  // swift(>=4.2)

/// This is an int8 on the clad side.
/// Proto field names are prefixed with "EXPRESSION_"
public enum Anki_Vector_ExternalInterface_FacialExpression: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// e.g. expression estimation disabled.
  case expressionUnknown // = 0
  case expressionNeutral // = 1
  case expressionHappiness // = 2
  case expressionSurprise // = 3
  case expressionAnger // = 4
  case expressionSadness // = 5

  /// Clad does not account for "Unknown" in the count.
  public static let expressionCount = expressionSadness
  case UNRECOGNIZED(Int)

  public init() {
    self = .expressionUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .expressionUnknown
    case 1: self = .expressionNeutral
    case 2: self = .expressionHappiness
    case 3: self = .expressionSurprise
    case 4: self = .expressionAnger
    case 5: self = .expressionSadness
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .expressionUnknown: return 0
    case .expressionNeutral: return 1
    case .expressionHappiness: return 2
    case .expressionSurprise: return 3
    case .expressionAnger: return 4
    case .expressionSadness: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_FacialExpression: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_FacialExpression] = [
    .expressionUnknown,
    .expressionNeutral,
    .expressionHappiness,
    .expressionSurprise,
    .expressionAnger,
    .expressionSadness,
  ]
}

#endif  // swift(>=4.2)

public enum Anki_Vector_ExternalInterface_FaceEnrollmentResult: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case success // = 0

  /// Failures:
  case sawWrongFace // = 1
  case sawMultipleFaces // = 2
  case timedOut // = 3
  case saveFailed // = 4
  case incomplete // = 5
  case cancelled // = 6
  case nameInUse // = 7
  case namedStorageFull // = 8
  case unknownFailure // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .success
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .success
    case 1: self = .sawWrongFace
    case 2: self = .sawMultipleFaces
    case 3: self = .timedOut
    case 4: self = .saveFailed
    case 5: self = .incomplete
    case 6: self = .cancelled
    case 7: self = .nameInUse
    case 8: self = .namedStorageFull
    case 9: self = .unknownFailure
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .success: return 0
    case .sawWrongFace: return 1
    case .sawMultipleFaces: return 2
    case .timedOut: return 3
    case .saveFailed: return 4
    case .incomplete: return 5
    case .cancelled: return 6
    case .nameInUse: return 7
    case .namedStorageFull: return 8
    case .unknownFailure: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_FaceEnrollmentResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_FaceEnrollmentResult] = [
    .success,
    .sawWrongFace,
    .sawMultipleFaces,
    .timedOut,
    .saveFailed,
    .incomplete,
    .cancelled,
    .nameInUse,
    .namedStorageFull,
    .unknownFailure,
  ]
}

#endif  // swift(>=4.2)

public enum Anki_Vector_ExternalInterface_BehaviorResults: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case behaviorInvalidState // = 0
  case behaviorCompleteState // = 1
  case behaviorWontActivateState // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .behaviorInvalidState
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .behaviorInvalidState
    case 1: self = .behaviorCompleteState
    case 2: self = .behaviorWontActivateState
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .behaviorInvalidState: return 0
    case .behaviorCompleteState: return 1
    case .behaviorWontActivateState: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_BehaviorResults: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_BehaviorResults] = [
    .behaviorInvalidState,
    .behaviorCompleteState,
    .behaviorWontActivateState,
  ]
}

#endif  // swift(>=4.2)

public enum Anki_Vector_ExternalInterface_ActionTagConstants: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case invalidSdkTag // = 0
  case firstSdkTag // = 2000001
  case lastSdkTag // = 3000000
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalidSdkTag
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalidSdkTag
    case 2000001: self = .firstSdkTag
    case 3000000: self = .lastSdkTag
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalidSdkTag: return 0
    case .firstSdkTag: return 2000001
    case .lastSdkTag: return 3000000
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_ActionTagConstants: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_ActionTagConstants] = [
    .invalidSdkTag,
    .firstSdkTag,
    .lastSdkTag,
  ]
}

#endif  // swift(>=4.2)

/// This is a uint8 in CLAD
public enum Anki_Vector_ExternalInterface_AlignmentType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// Align the tips of the lift fingers with the target object
  case liftFinger // = 1

  /// Align the flat part of the lift with the object (useful for getting the fingers in the cube's grooves)
  case liftPlate // = 2

  /// Align the front of Vector's body (useful for when the lift is up)
  case body // = 3

  /// For use with distanceFromMarker parameter
  case custom // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .liftFinger
    case 2: self = .liftPlate
    case 3: self = .body
    case 4: self = .custom
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .liftFinger: return 1
    case .liftPlate: return 2
    case .body: return 3
    case .custom: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_AlignmentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_AlignmentType] = [
    .unknown,
    .liftFinger,
    .liftPlate,
    .body,
    .custom,
  ]
}

#endif  // swift(>=4.2)

public enum Anki_Vector_ExternalInterface_BatteryLevel: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case low // = 1
  case nominal // = 2
  case full // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .low
    case 2: self = .nominal
    case 3: self = .full
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .low: return 1
    case .nominal: return 2
    case .full: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_BatteryLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_BatteryLevel] = [
    .unknown,
    .low,
    .nominal,
    .full,
  ]
}

#endif  // swift(>=4.2)

/// Constants associated with the audio feed
public enum Anki_Vector_ExternalInterface_AudioConstants: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// error value
  case null // = 0

  /// The number of audio directions the four microphones can isolate
  case micDetectionDirections // = 12

  /// The number of audio samples in each internal audio chunk
  case sampleCountsPerEngineMessage // = 160

  /// The number of audio samples delivered in each audio feed response
  case sampleCountsPerSdkMessage // = 1600

  /// The sampling rate victor's microphones record at
  case microphoneSampleRate // = 15625

  /// The sampling rate the robot processes audio at
  case processedSampleRate // = 16000
  case UNRECOGNIZED(Int)

  public init() {
    self = .null
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .null
    case 12: self = .micDetectionDirections
    case 160: self = .sampleCountsPerEngineMessage
    case 1600: self = .sampleCountsPerSdkMessage
    case 15625: self = .microphoneSampleRate
    case 16000: self = .processedSampleRate
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .null: return 0
    case .micDetectionDirections: return 12
    case .sampleCountsPerEngineMessage: return 160
    case .sampleCountsPerSdkMessage: return 1600
    case .microphoneSampleRate: return 15625
    case .processedSampleRate: return 16000
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_AudioConstants: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_AudioConstants] = [
    .null,
    .micDetectionDirections,
    .sampleCountsPerEngineMessage,
    .sampleCountsPerSdkMessage,
    .microphoneSampleRate,
    .processedSampleRate,
  ]
}

#endif  // swift(>=4.2)

/// The robot can process audio in a variety of ways
public enum Anki_Vector_ExternalInterface_AudioProcessingMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// error value
  case audioUnknown // = 0

  /// deactivates audio SDK mode
  case audioOff // = 1

  /// unprocessed single microphone data - most performant on robot
  case audioFastMode // = 2

  /// beamforming support for focusing on specific direction - sounds cleanest
  case audioDirectionalMode // = 3

  /// multi-microphone non-beamforming - best for voice detection programs
  case audioVoiceDetectMode // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .audioUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .audioUnknown
    case 1: self = .audioOff
    case 2: self = .audioFastMode
    case 3: self = .audioDirectionalMode
    case 4: self = .audioVoiceDetectMode
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .audioUnknown: return 0
    case .audioOff: return 1
    case .audioFastMode: return 2
    case .audioDirectionalMode: return 3
    case .audioVoiceDetectMode: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_AudioProcessingMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_AudioProcessingMode] = [
    .audioUnknown,
    .audioOff,
    .audioFastMode,
    .audioDirectionalMode,
    .audioVoiceDetectMode,
  ]
}

#endif  // swift(>=4.2)

public enum Anki_Vector_ExternalInterface_MasterVolumeLevel: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case volumeLow // = 0
  case volumeMediumLow // = 1
  case volumeMedium // = 2
  case volumeMediumHigh // = 3
  case volumeHigh // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .volumeLow
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .volumeLow
    case 1: self = .volumeMediumLow
    case 2: self = .volumeMedium
    case 3: self = .volumeMediumHigh
    case 4: self = .volumeHigh
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .volumeLow: return 0
    case .volumeMediumLow: return 1
    case .volumeMedium: return 2
    case .volumeMediumHigh: return 3
    case .volumeHigh: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_MasterVolumeLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_MasterVolumeLevel] = [
    .volumeLow,
    .volumeMediumLow,
    .volumeMedium,
    .volumeMediumHigh,
    .volumeHigh,
  ]
}

#endif  // swift(>=4.2)

/// A null message used by streams to verify that the client is
/// still connected.
public struct Anki_Vector_ExternalInterface_KeepAlivePing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An animation trigger object.
public struct Anki_Vector_ExternalInterface_AnimationTrigger {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of a given animation trigger.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An animation object.
public struct Anki_Vector_ExternalInterface_Animation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of a given animation.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// See the DriveWheels rpc for more details.
public struct Anki_Vector_ExternalInterface_DriveWheelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var leftWheelMmps: Float = 0

  public var rightWheelMmps: Float = 0

  public var leftWheelMmps2: Float = 0

  public var rightWheelMmps2: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// See the DriveWheels rpc for more details.
public struct Anki_Vector_ExternalInterface_DriveWheelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A generic status.
  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// See the MoveHead rpc for more details.
public struct Anki_Vector_ExternalInterface_MoveHeadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var speedRadPerSec: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// See the MoveHead rpc for more details.
public struct Anki_Vector_ExternalInterface_MoveHeadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A generic status.
  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// See the MoveLift rpc for more details.
public struct Anki_Vector_ExternalInterface_MoveLiftRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var speedRadPerSec: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// See the MoveLift rpc for more details.
public struct Anki_Vector_ExternalInterface_MoveLiftResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A generic status.
  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// See the StopAllMotors rpc for more details.
public struct Anki_Vector_ExternalInterface_StopAllMotorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// See the StopAllMotors rpc for more details.
public struct Anki_Vector_ExternalInterface_StopAllMotorsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// See PlayAnimationTrigger rpc for more details.
public struct Anki_Vector_ExternalInterface_PlayAnimationTriggerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The animation trigger to play.
  public var animationTrigger: Anki_Vector_ExternalInterface_AnimationTrigger {
    get {return _animationTrigger ?? Anki_Vector_ExternalInterface_AnimationTrigger()}
    set {_animationTrigger = newValue}
  }
  /// Returns true if `animationTrigger` has been explicitly set.
  public var hasAnimationTrigger: Bool {return self._animationTrigger != nil}
  /// Clears the value of `animationTrigger`. Subsequent reads from it will return its default value.
  public mutating func clearAnimationTrigger() {self._animationTrigger = nil}

  /// The number of times to play the animation in a row.
  public var loops: UInt32 = 0

  /// Automatically ignore the lift track if Vector is currently carrying an object.
  public var useLiftSafe: Bool = false

  /// Ignore any movement of Vector's body when playing the animation.
  public var ignoreBodyTrack: Bool = false

  /// Ignore any movement of Vector's head when playing the animation.
  public var ignoreHeadTrack: Bool = false

  /// Ignore any movement of Vector's lift when playing the animation.
  public var ignoreLiftTrack: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _animationTrigger: Anki_Vector_ExternalInterface_AnimationTrigger? = nil
}

/// See PlayAnimation rpc for more details.
public struct Anki_Vector_ExternalInterface_PlayAnimationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The animation to play.
  public var animation: Anki_Vector_ExternalInterface_Animation {
    get {return _animation ?? Anki_Vector_ExternalInterface_Animation()}
    set {_animation = newValue}
  }
  /// Returns true if `animation` has been explicitly set.
  public var hasAnimation: Bool {return self._animation != nil}
  /// Clears the value of `animation`. Subsequent reads from it will return its default value.
  public mutating func clearAnimation() {self._animation = nil}

  /// The number of times to play the animation in a row.
  public var loops: UInt32 = 0

  /// Ignore any movement of Vector's body in the given animation.
  public var ignoreBodyTrack: Bool = false

  /// Ignore any movement of Vector's head in the given animation.
  public var ignoreHeadTrack: Bool = false

  /// Ignore any movement of Vector's lift in the given animation.
  public var ignoreLiftTrack: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _animation: Anki_Vector_ExternalInterface_Animation? = nil
}

/// See PlayAnimation rpc for more details.
public struct Anki_Vector_ExternalInterface_PlayAnimationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A generic status.
  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// Information on whether the animation played successfully.
  public var result: Anki_Vector_ExternalInterface_BehaviorResults = .behaviorInvalidState

  /// The animation that the robot executed.
  public var animation: Anki_Vector_ExternalInterface_Animation {
    get {return _animation ?? Anki_Vector_ExternalInterface_Animation()}
    set {_animation = newValue}
  }
  /// Returns true if `animation` has been explicitly set.
  public var hasAnimation: Bool {return self._animation != nil}
  /// Clears the value of `animation`. Subsequent reads from it will return its default value.
  public mutating func clearAnimation() {self._animation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
  fileprivate var _animation: Anki_Vector_ExternalInterface_Animation? = nil
}

/// See ListAnimations rpc for more details.
public struct Anki_Vector_ExternalInterface_ListAnimationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// See ListAnimations rpc for more details.
public struct Anki_Vector_ExternalInterface_ListAnimationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A generic status.
  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The animations that Vector knows.
  public var animationNames: [Anki_Vector_ExternalInterface_Animation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// See ListAnimationTriggers rpc for more details.
public struct Anki_Vector_ExternalInterface_ListAnimationTriggersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// See ListAnimationTriggers rpc for more details.
public struct Anki_Vector_ExternalInterface_ListAnimationTriggersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A generic status.
  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The animation triggers that Vector knows.
  public var animationTriggerNames: [Anki_Vector_ExternalInterface_AnimationTrigger] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// See DisplayFaceImageRGB rpc for more details.
public struct Anki_Vector_ExternalInterface_DisplayFaceImageRGBRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The image to render.
  public var faceData: Data = Data()

  /// How long to display the image on the face.
  public var durationMs: UInt32 = 0

  /// If this image should overwrite any current images on the face.
  public var interruptRunning: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// See DisplayFaceImageRGB rpc for more details.
public struct Anki_Vector_ExternalInterface_DisplayFaceImageRGBResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A generic status.
  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_MeetVictorFaceScanStarted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_MeetVictorFaceScanComplete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_Status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var statusType: Anki_Vector_ExternalInterface_Status.OneOf_StatusType? = nil

  public var meetVictorFaceScanStarted: Anki_Vector_ExternalInterface_MeetVictorFaceScanStarted {
    get {
      if case .meetVictorFaceScanStarted(let v)? = statusType {return v}
      return Anki_Vector_ExternalInterface_MeetVictorFaceScanStarted()
    }
    set {statusType = .meetVictorFaceScanStarted(newValue)}
  }

  public var meetVictorFaceScanComplete: Anki_Vector_ExternalInterface_MeetVictorFaceScanComplete {
    get {
      if case .meetVictorFaceScanComplete(let v)? = statusType {return v}
      return Anki_Vector_ExternalInterface_MeetVictorFaceScanComplete()
    }
    set {statusType = .meetVictorFaceScanComplete(newValue)}
  }

  public var faceEnrollmentCompleted: Anki_Vector_ExternalInterface_FaceEnrollmentCompleted {
    get {
      if case .faceEnrollmentCompleted(let v)? = statusType {return v}
      return Anki_Vector_ExternalInterface_FaceEnrollmentCompleted()
    }
    set {statusType = .faceEnrollmentCompleted(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_StatusType: Equatable {
    case meetVictorFaceScanStarted(Anki_Vector_ExternalInterface_MeetVictorFaceScanStarted)
    case meetVictorFaceScanComplete(Anki_Vector_ExternalInterface_MeetVictorFaceScanComplete)
    case faceEnrollmentCompleted(Anki_Vector_ExternalInterface_FaceEnrollmentCompleted)

  #if !swift(>=4.1)
    public static func ==(lhs: Anki_Vector_ExternalInterface_Status.OneOf_StatusType, rhs: Anki_Vector_ExternalInterface_Status.OneOf_StatusType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.meetVictorFaceScanStarted, .meetVictorFaceScanStarted): return {
        guard case .meetVictorFaceScanStarted(let l) = lhs, case .meetVictorFaceScanStarted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.meetVictorFaceScanComplete, .meetVictorFaceScanComplete): return {
        guard case .meetVictorFaceScanComplete(let l) = lhs, case .meetVictorFaceScanComplete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.faceEnrollmentCompleted, .faceEnrollmentCompleted): return {
        guard case .faceEnrollmentCompleted(let l) = lhs, case .faceEnrollmentCompleted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Anki_Vector_ExternalInterface_WakeWord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var wakeWordType: Anki_Vector_ExternalInterface_WakeWord.OneOf_WakeWordType? = nil

  public var wakeWordBegin: Anki_Vector_ExternalInterface_WakeWordBegin {
    get {
      if case .wakeWordBegin(let v)? = wakeWordType {return v}
      return Anki_Vector_ExternalInterface_WakeWordBegin()
    }
    set {wakeWordType = .wakeWordBegin(newValue)}
  }

  public var wakeWordEnd: Anki_Vector_ExternalInterface_WakeWordEnd {
    get {
      if case .wakeWordEnd(let v)? = wakeWordType {return v}
      return Anki_Vector_ExternalInterface_WakeWordEnd()
    }
    set {wakeWordType = .wakeWordEnd(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_WakeWordType: Equatable {
    case wakeWordBegin(Anki_Vector_ExternalInterface_WakeWordBegin)
    case wakeWordEnd(Anki_Vector_ExternalInterface_WakeWordEnd)

  #if !swift(>=4.1)
    public static func ==(lhs: Anki_Vector_ExternalInterface_WakeWord.OneOf_WakeWordType, rhs: Anki_Vector_ExternalInterface_WakeWord.OneOf_WakeWordType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.wakeWordBegin, .wakeWordBegin): return {
        guard case .wakeWordBegin(let l) = lhs, case .wakeWordBegin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.wakeWordEnd, .wakeWordEnd): return {
        guard case .wakeWordEnd(let l) = lhs, case .wakeWordEnd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Anki_Vector_ExternalInterface_TimeStampedStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_Status {
    get {return _status ?? Anki_Vector_ExternalInterface_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var timestampUtc: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_Status? = nil
}

public struct Anki_Vector_ExternalInterface_PoseStruct {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Translation
  public var x: Float = 0

  public var y: Float = 0

  public var z: Float = 0

  /// Rotation quaternion
  public var q0: Float = 0

  public var q1: Float = 0

  public var q2: Float = 0

  public var q3: Float = 0

  /// Which coordinate frame this pose is in (0 for none or unknown)
  public var originID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// All values are in mm/s^2.
public struct Anki_Vector_ExternalInterface_AccelData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: Float = 0

  public var y: Float = 0

  public var z: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// All values are in rad/s.
public struct Anki_Vector_ExternalInterface_GyroData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: Float = 0

  public var y: Float = 0

  public var z: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_ProxData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var distanceMm: UInt32 = 0

  public var signalQuality: Float = 0

  /// The sensor has confirmed it has not detected anything up to its max range
  public var unobstructed: Bool = false

  /// The sensor detected an object in the valid operating range
  public var foundObject: Bool = false

  /// Lift (or object on lift) is occluding the sensor
  public var isLiftInFov: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_TouchData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Raw input from the touch sensor
  public var rawTouchValue: UInt32 = 0

  /// Robot's context aware evaluation of whether it currently is or isn't being touched
  public var isBeingTouched: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_RobotState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pose: Anki_Vector_ExternalInterface_PoseStruct {
    get {return _storage._pose ?? Anki_Vector_ExternalInterface_PoseStruct()}
    set {_uniqueStorage()._pose = newValue}
  }
  /// Returns true if `pose` has been explicitly set.
  public var hasPose: Bool {return _storage._pose != nil}
  /// Clears the value of `pose`. Subsequent reads from it will return its default value.
  public mutating func clearPose() {_uniqueStorage()._pose = nil}

  public var poseAngleRad: Float {
    get {return _storage._poseAngleRad}
    set {_uniqueStorage()._poseAngleRad = newValue}
  }

  public var posePitchRad: Float {
    get {return _storage._posePitchRad}
    set {_uniqueStorage()._posePitchRad = newValue}
  }

  public var leftWheelSpeedMmps: Float {
    get {return _storage._leftWheelSpeedMmps}
    set {_uniqueStorage()._leftWheelSpeedMmps = newValue}
  }

  public var rightWheelSpeedMmps: Float {
    get {return _storage._rightWheelSpeedMmps}
    set {_uniqueStorage()._rightWheelSpeedMmps = newValue}
  }

  public var headAngleRad: Float {
    get {return _storage._headAngleRad}
    set {_uniqueStorage()._headAngleRad = newValue}
  }

  public var liftHeightMm: Float {
    get {return _storage._liftHeightMm}
    set {_uniqueStorage()._liftHeightMm = newValue}
  }

  public var accel: Anki_Vector_ExternalInterface_AccelData {
    get {return _storage._accel ?? Anki_Vector_ExternalInterface_AccelData()}
    set {_uniqueStorage()._accel = newValue}
  }
  /// Returns true if `accel` has been explicitly set.
  public var hasAccel: Bool {return _storage._accel != nil}
  /// Clears the value of `accel`. Subsequent reads from it will return its default value.
  public mutating func clearAccel() {_uniqueStorage()._accel = nil}

  public var gyro: Anki_Vector_ExternalInterface_GyroData {
    get {return _storage._gyro ?? Anki_Vector_ExternalInterface_GyroData()}
    set {_uniqueStorage()._gyro = newValue}
  }
  /// Returns true if `gyro` has been explicitly set.
  public var hasGyro: Bool {return _storage._gyro != nil}
  /// Clears the value of `gyro`. Subsequent reads from it will return its default value.
  public mutating func clearGyro() {_uniqueStorage()._gyro = nil}

  public var carryingObjectID: Int32 {
    get {return _storage._carryingObjectID}
    set {_uniqueStorage()._carryingObjectID = newValue}
  }

  /// Not supported by engine
  public var carryingObjectOnTopID: Int32 {
    get {return _storage._carryingObjectOnTopID}
    set {_uniqueStorage()._carryingObjectOnTopID = newValue}
  }

  public var headTrackingObjectID: Int32 {
    get {return _storage._headTrackingObjectID}
    set {_uniqueStorage()._headTrackingObjectID = newValue}
  }

  public var localizedToObjectID: Int32 {
    get {return _storage._localizedToObjectID}
    set {_uniqueStorage()._localizedToObjectID = newValue}
  }

  public var lastImageTimeStamp: UInt32 {
    get {return _storage._lastImageTimeStamp}
    set {_uniqueStorage()._lastImageTimeStamp = newValue}
  }

  public var status: UInt32 {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var proxData: Anki_Vector_ExternalInterface_ProxData {
    get {return _storage._proxData ?? Anki_Vector_ExternalInterface_ProxData()}
    set {_uniqueStorage()._proxData = newValue}
  }
  /// Returns true if `proxData` has been explicitly set.
  public var hasProxData: Bool {return _storage._proxData != nil}
  /// Clears the value of `proxData`. Subsequent reads from it will return its default value.
  public mutating func clearProxData() {_uniqueStorage()._proxData = nil}

  public var touchData: Anki_Vector_ExternalInterface_TouchData {
    get {return _storage._touchData ?? Anki_Vector_ExternalInterface_TouchData()}
    set {_uniqueStorage()._touchData = newValue}
  }
  /// Returns true if `touchData` has been explicitly set.
  public var hasTouchData: Bool {return _storage._touchData != nil}
  /// Clears the value of `touchData`. Subsequent reads from it will return its default value.
  public mutating func clearTouchData() {_uniqueStorage()._touchData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Anki_Vector_ExternalInterface_CladPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: Float = 0

  public var y: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_CladRect {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var xTopLeft: Float = 0

  public var yTopLeft: Float = 0

  public var width: Float = 0

  public var height: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_RobotObservedFace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// negative: tracked but not recognized; positive: recognized face
  public var faceID: Int32 {
    get {return _storage._faceID}
    set {_uniqueStorage()._faceID = newValue}
  }

  public var timestamp: UInt32 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  public var pose: Anki_Vector_ExternalInterface_PoseStruct {
    get {return _storage._pose ?? Anki_Vector_ExternalInterface_PoseStruct()}
    set {_uniqueStorage()._pose = newValue}
  }
  /// Returns true if `pose` has been explicitly set.
  public var hasPose: Bool {return _storage._pose != nil}
  /// Clears the value of `pose`. Subsequent reads from it will return its default value.
  public mutating func clearPose() {_uniqueStorage()._pose = nil}

  /// position in image coords
  public var imgRect: Anki_Vector_ExternalInterface_CladRect {
    get {return _storage._imgRect ?? Anki_Vector_ExternalInterface_CladRect()}
    set {_uniqueStorage()._imgRect = newValue}
  }
  /// Returns true if `imgRect` has been explicitly set.
  public var hasImgRect: Bool {return _storage._imgRect != nil}
  /// Clears the value of `imgRect`. Subsequent reads from it will return its default value.
  public mutating func clearImgRect() {_uniqueStorage()._imgRect = nil}

  /// Empty if none assigned yet
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var expression: Anki_Vector_ExternalInterface_FacialExpression {
    get {return _storage._expression}
    set {_uniqueStorage()._expression = newValue}
  }

  /// Individual expression values histogram, sums to 100 (Exception: all zero if expression=Unknown)
  public var expressionValues: [UInt32] {
    get {return _storage._expressionValues}
    set {_uniqueStorage()._expressionValues = newValue}
  }

  /// Face landmarks
  public var leftEye: [Anki_Vector_ExternalInterface_CladPoint] {
    get {return _storage._leftEye}
    set {_uniqueStorage()._leftEye = newValue}
  }

  public var rightEye: [Anki_Vector_ExternalInterface_CladPoint] {
    get {return _storage._rightEye}
    set {_uniqueStorage()._rightEye = newValue}
  }

  public var nose: [Anki_Vector_ExternalInterface_CladPoint] {
    get {return _storage._nose}
    set {_uniqueStorage()._nose = newValue}
  }

  public var mouth: [Anki_Vector_ExternalInterface_CladPoint] {
    get {return _storage._mouth}
    set {_uniqueStorage()._mouth = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RobotChangedObservedFaceID
///  This generally happens when a tracked face (negative ID) is recognized and
///  receives a positive ID or when face records get merged
public struct Anki_Vector_ExternalInterface_RobotChangedObservedFaceID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var oldID: Int32 = 0

  public var newID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_FaceEnrollmentCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Anki_Vector_ExternalInterface_FaceEnrollmentResult = .success

  public var faceID: Int32 = 0

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_CancelFaceEnrollmentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_CancelFaceEnrollmentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_RequestEnrolledNamesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_LoadedKnownFace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var secondsSinceFirstEnrolled: Int64 = 0

  public var secondsSinceLastUpdated: Int64 = 0

  public var secondsSinceLastSeen: Int64 = 0

  public var lastSeenSecondsSinceEpoch: Int64 = 0

  public var faceID: Int32 = 0

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_RobotRenamedEnrolledFace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var faceID: Int32 = 0

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_RequestEnrolledNamesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var faces: [Anki_Vector_ExternalInterface_LoadedKnownFace] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_UpdateEnrolledFaceByIDRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var faceID: Int32 = 0

  public var oldName: String = String()

  public var newName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_UpdateEnrolledFaceByIDResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_EraseEnrolledFaceByIDRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var faceID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_EraseEnrolledFaceByIDResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_EraseAllEnrolledFacesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_EraseAllEnrolledFacesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_SetFaceToEnrollRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  /// The ID of a specific observed face to enroll (0 for next one we see)
  public var observedID: Int32 = 0

  /// The ID of an existing face to merge final enrollment into (0 for none,
  public var saveID: Int32 = 0

  /// Save to robot's NVStorage when done (NOTE: will (re)save everyone enrolled!)
  public var saveToRobot: Bool = false

  /// Play say-name/celebration animations on success before completing
  public var sayName: Bool = false

  /// Starts special music during say-name animations (will leave music playing!)
  public var useMusic: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_SetFaceToEnrollResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_DriveOffChargerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_DriveOffChargerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_BehaviorResults = .behaviorInvalidState

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_DriveOnChargerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_DriveOnChargerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_BehaviorResults = .behaviorInvalidState

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_FindFacesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_FindFacesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_BehaviorResults = .behaviorInvalidState

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_LookAroundInPlaceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_LookAroundInPlaceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_BehaviorResults = .behaviorInvalidState

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

///this triggers a Vector Behavior, different from RollObjectRequest which triggers an Action
public struct Anki_Vector_ExternalInterface_RollBlockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_RollBlockResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_BehaviorResults = .behaviorInvalidState

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_WakeWordBegin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_WakeWordEnd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var intentHeard: Bool = false

  public var intentJson: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_UserIntent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var intentID: UInt32 = 0

  public var jsonData: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_PhotoInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var photoID: UInt32 = 0

  public var timestampUtc: UInt32 = 0

  public var photoCopiedToApp: Bool = false

  public var thumbCopiedToApp: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_PhotosInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_PhotosInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var photoInfos: [Anki_Vector_ExternalInterface_PhotoInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_PhotoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var photoID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_PhotoPathMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var fullPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_PhotoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var success: Bool = false

  public var image: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_ThumbnailRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var photoID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_ThumbnailPathMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var fullPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_ThumbnailResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var success: Bool = false

  public var image: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_DeletePhotoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var photoID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_DeletePhotoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_PhotoTaken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var photoID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Struct containing all the information relevant to how a 
/// path should be modified or traversed.
public struct Anki_Vector_ExternalInterface_PathMotionProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var speedMmps: Float = 0

  public var accelMmps2: Float = 0

  public var decelMmps2: Float = 0

  public var pointTurnSpeedRadPerSec: Float = 0

  public var pointTurnAccelRadPerSec2: Float = 0

  public var pointTurnDecelRadPerSec2: Float = 0

  public var dockSpeedMmps: Float = 0

  public var dockAccelMmps2: Float = 0

  public var dockDecelMmps2: Float = 0

  public var reverseSpeedMmps: Float = 0

  public var isCustom: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The possible results of running an action.
public struct Anki_Vector_ExternalInterface_ActionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Anki_Vector_ExternalInterface_ActionResult.ActionResultCode = .actionResultSuccess

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The possible results of running an action.
  public enum ActionResultCode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Action completed successfully.
    case actionResultSuccess // = 0

    /// Action is still running.
    case actionResultRunning // = 16777216

    /// Action was cancelled by SDK request
    case actionResultCancelledWhileRunning // = 33554432

    /// Initial state of an Action to indicate it has not yet started.
    case notStarted // = 33554433

    /// Action aborted itself (e.g. had invalid attributes, or a runtime failure).
    case abort // = 50331648

    /// Animation Action aborted itself (e.g. there was an error playing the animation).
    case animAborted // = 50331649

    /// There was an error related to vision markers.
    case badMarker // = 50331650

    /// There was a problem related to a subscribed or unsupported message tag
    case badMessageTag // = 50331651

    /// There was a problem with the Object ID provided (e.g. there is no Object with that ID).
    case badObject // = 50331652

    /// There was a problem with the Pose provided.
    case badPose // = 50331653

    /// The SDK-provided tag was bad.
    case badTag // = 50331654

    /// Vector is on the charger but cannot sense the contacts. Charger may be unplugged.
    case chargerUnpluggedAbort // = 50331655
    case cliffAlignFailedTimeout // = 50331656
    case cliffAlignFailedNoTurning // = 50331657
    case cliffAlignFailedOverTurning // = 50331658
    case cliffAlignFailedNoWhite // = 50331659
    case cliffAlignFailedStopped // = 50331660

    /// Shouldn't occur outside of factory.
    case failedSettingCalibration // = 50331661

    /// There was an error following the planned path.
    case followingPathButNotTraversing // = 50331662

    /// The action was interrupted by another Action or Behavior.
    case interrupted // = 50331663

    /// The robot ended up in an "off treads state" not valid for this action (e.g. the robot was placed on its back while executing a turn).
    case invalidOffTreadsState // = 50331664

    /// The Up Axis of a carried object doesn't match the desired placement pose.
    case mismatchedUpAxis // = 50331665

    /// No valid Animation name was found.
    case noAnimName // = 50331666

    /// An invalid distance value was given.
    case noDistanceSet // = 50331667

    /// There was a problem with the Face ID (e.g. Vector doesn't no where it is).
    case noFace // = 50331668

    /// No goal pose was set.
    case noGoalSet // = 50331669

    /// No pre-action poses were found (e.g. could not get into position).
    case noPreactionPoses // = 50331670

    /// No object is being carried, but the action requires one.
    case notCarryingObjectAbort // = 50331671

    /// Vector is expected to be on the charger, but is not.
    case notOnChargerAbort // = 50331672

    /// No sub-action was provided.
    case nullSubaction // = 50331673

    /// Vector was unable to plan a path.
    case pathPlanningFailedAbort // = 50331674

    /// The object that Vector is attempting to pickup is unexpectedly moving (e.g it is being moved by someone else).
    case pickupObjectUnexpectedlyMoving // = 50331675

    /// Shouldn't occur in SDK usage.
    case sendMessageToRobotFailed // = 50331676

    /// Vector is unexpectedly still carrying an object.
    case stillCarryingObject // = 50331677

    /// The Action timed out before completing correctly.
    case timeout // = 50331678

    /// One or more movement tracks (Head, Lift, Body, Face, Backpack Lights, Audio) are already being used by another Action.
    case tracksLocked // = 50331679

    /// There was an internal error related to an unexpected type of dock action.
    case unexpectedDockAction // = 50331680

    /// Shouldn't occur outside of factory.
    case unknownToolCode // = 50331681

    /// There was a problem in the subclass's update on the robot.
    case updateDerivedFailed // = 50331682

    /// Vector did not see the expected result (e.g. unable to see cube in the expected position after a related action).
    case visualObservationFailed // = 50331683

    /// Action is not permitted on the charger.
    case shouldntDriveOnCharger // = 50331684

    /// The Action failed, but may succeed if retried.
    case retry // = 67108864

    /// Failed to get into position.
    case didNotReachPreactionPose // = 67108865

    /// Failed to follow the planned path.
    case failedTraversingPath // = 67108866

    /// The previous attempt to pick and place an object failed.
    case lastPickAndPlaceFailed // = 67108867

    /// The required motor isn't moving so the action cannot complete.
    case motorStoppedMakingProgress // = 67108868

    /// Not carrying an object when it was expected, but may succeed if the action is retried.
    case notCarryingObjectRetry // = 67108869

    /// Driving onto the charger failed, but may succeed if the action is retried.
    case notOnChargerRetry // = 67108870

    /// Vector was unable to plan a path, but may succeed if the action is retried.
    case pathPlanningFailedRetry // = 67108871

    /// There is no room to place the object at the desired destination.
    case placementGoalNotFree // = 67108872

    /// The object that Vector thought he was lifting didn't start moving, so he must have missed.
    case pickupObjectUnexpectedlyNotMoving // = 67108873

    /// Vector failed to drive off the charger.
    case stillOnCharger // = 67108874

    /// Vector's pitch is at an unexpected angle for the Action.
    case unexpectedPitchAngle // = 67108875
    case UNRECOGNIZED(Int)

    public init() {
      self = .actionResultSuccess
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .actionResultSuccess
      case 16777216: self = .actionResultRunning
      case 33554432: self = .actionResultCancelledWhileRunning
      case 33554433: self = .notStarted
      case 50331648: self = .abort
      case 50331649: self = .animAborted
      case 50331650: self = .badMarker
      case 50331651: self = .badMessageTag
      case 50331652: self = .badObject
      case 50331653: self = .badPose
      case 50331654: self = .badTag
      case 50331655: self = .chargerUnpluggedAbort
      case 50331656: self = .cliffAlignFailedTimeout
      case 50331657: self = .cliffAlignFailedNoTurning
      case 50331658: self = .cliffAlignFailedOverTurning
      case 50331659: self = .cliffAlignFailedNoWhite
      case 50331660: self = .cliffAlignFailedStopped
      case 50331661: self = .failedSettingCalibration
      case 50331662: self = .followingPathButNotTraversing
      case 50331663: self = .interrupted
      case 50331664: self = .invalidOffTreadsState
      case 50331665: self = .mismatchedUpAxis
      case 50331666: self = .noAnimName
      case 50331667: self = .noDistanceSet
      case 50331668: self = .noFace
      case 50331669: self = .noGoalSet
      case 50331670: self = .noPreactionPoses
      case 50331671: self = .notCarryingObjectAbort
      case 50331672: self = .notOnChargerAbort
      case 50331673: self = .nullSubaction
      case 50331674: self = .pathPlanningFailedAbort
      case 50331675: self = .pickupObjectUnexpectedlyMoving
      case 50331676: self = .sendMessageToRobotFailed
      case 50331677: self = .stillCarryingObject
      case 50331678: self = .timeout
      case 50331679: self = .tracksLocked
      case 50331680: self = .unexpectedDockAction
      case 50331681: self = .unknownToolCode
      case 50331682: self = .updateDerivedFailed
      case 50331683: self = .visualObservationFailed
      case 50331684: self = .shouldntDriveOnCharger
      case 67108864: self = .retry
      case 67108865: self = .didNotReachPreactionPose
      case 67108866: self = .failedTraversingPath
      case 67108867: self = .lastPickAndPlaceFailed
      case 67108868: self = .motorStoppedMakingProgress
      case 67108869: self = .notCarryingObjectRetry
      case 67108870: self = .notOnChargerRetry
      case 67108871: self = .pathPlanningFailedRetry
      case 67108872: self = .placementGoalNotFree
      case 67108873: self = .pickupObjectUnexpectedlyNotMoving
      case 67108874: self = .stillOnCharger
      case 67108875: self = .unexpectedPitchAngle
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .actionResultSuccess: return 0
      case .actionResultRunning: return 16777216
      case .actionResultCancelledWhileRunning: return 33554432
      case .notStarted: return 33554433
      case .abort: return 50331648
      case .animAborted: return 50331649
      case .badMarker: return 50331650
      case .badMessageTag: return 50331651
      case .badObject: return 50331652
      case .badPose: return 50331653
      case .badTag: return 50331654
      case .chargerUnpluggedAbort: return 50331655
      case .cliffAlignFailedTimeout: return 50331656
      case .cliffAlignFailedNoTurning: return 50331657
      case .cliffAlignFailedOverTurning: return 50331658
      case .cliffAlignFailedNoWhite: return 50331659
      case .cliffAlignFailedStopped: return 50331660
      case .failedSettingCalibration: return 50331661
      case .followingPathButNotTraversing: return 50331662
      case .interrupted: return 50331663
      case .invalidOffTreadsState: return 50331664
      case .mismatchedUpAxis: return 50331665
      case .noAnimName: return 50331666
      case .noDistanceSet: return 50331667
      case .noFace: return 50331668
      case .noGoalSet: return 50331669
      case .noPreactionPoses: return 50331670
      case .notCarryingObjectAbort: return 50331671
      case .notOnChargerAbort: return 50331672
      case .nullSubaction: return 50331673
      case .pathPlanningFailedAbort: return 50331674
      case .pickupObjectUnexpectedlyMoving: return 50331675
      case .sendMessageToRobotFailed: return 50331676
      case .stillCarryingObject: return 50331677
      case .timeout: return 50331678
      case .tracksLocked: return 50331679
      case .unexpectedDockAction: return 50331680
      case .unknownToolCode: return 50331681
      case .updateDerivedFailed: return 50331682
      case .visualObservationFailed: return 50331683
      case .shouldntDriveOnCharger: return 50331684
      case .retry: return 67108864
      case .didNotReachPreactionPose: return 67108865
      case .failedTraversingPath: return 67108866
      case .lastPickAndPlaceFailed: return 67108867
      case .motorStoppedMakingProgress: return 67108868
      case .notCarryingObjectRetry: return 67108869
      case .notOnChargerRetry: return 67108870
      case .pathPlanningFailedRetry: return 67108871
      case .placementGoalNotFree: return 67108872
      case .pickupObjectUnexpectedlyNotMoving: return 67108873
      case .stillOnCharger: return 67108874
      case .unexpectedPitchAngle: return 67108875
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_ActionResult.ActionResultCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_ActionResult.ActionResultCode] = [
    .actionResultSuccess,
    .actionResultRunning,
    .actionResultCancelledWhileRunning,
    .notStarted,
    .abort,
    .animAborted,
    .badMarker,
    .badMessageTag,
    .badObject,
    .badPose,
    .badTag,
    .chargerUnpluggedAbort,
    .cliffAlignFailedTimeout,
    .cliffAlignFailedNoTurning,
    .cliffAlignFailedOverTurning,
    .cliffAlignFailedNoWhite,
    .cliffAlignFailedStopped,
    .failedSettingCalibration,
    .followingPathButNotTraversing,
    .interrupted,
    .invalidOffTreadsState,
    .mismatchedUpAxis,
    .noAnimName,
    .noDistanceSet,
    .noFace,
    .noGoalSet,
    .noPreactionPoses,
    .notCarryingObjectAbort,
    .notOnChargerAbort,
    .nullSubaction,
    .pathPlanningFailedAbort,
    .pickupObjectUnexpectedlyMoving,
    .sendMessageToRobotFailed,
    .stillCarryingObject,
    .timeout,
    .tracksLocked,
    .unexpectedDockAction,
    .unknownToolCode,
    .updateDerivedFailed,
    .visualObservationFailed,
    .shouldntDriveOnCharger,
    .retry,
    .didNotReachPreactionPose,
    .failedTraversingPath,
    .lastPickAndPlaceFailed,
    .motorStoppedMakingProgress,
    .notCarryingObjectRetry,
    .notOnChargerRetry,
    .pathPlanningFailedRetry,
    .placementGoalNotFree,
    .pickupObjectUnexpectedlyNotMoving,
    .stillOnCharger,
    .unexpectedPitchAngle,
  ]
}

#endif  // swift(>=4.2)

/// Cancel a previously-requested action. Action requests include GoToPoseRequest, DockWithCubeRequest, DriveStraightRequest, TurnInPlaceRequest, SetHeadAngleRequest, and SetLiftHeightRequest.
public struct Anki_Vector_ExternalInterface_CancelActionByIdTagRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Use the id_tag provided to the action request
  public var idTag: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from the robot to CancelActionByIdTagRequest.
public struct Anki_Vector_ExternalInterface_CancelActionByIdTagResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A generic status.
  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// GotoPose
public struct Anki_Vector_ExternalInterface_GoToPoseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var xMm: Float = 0

  public var yMm: Float = 0

  public var rad: Float = 0

  public var motionProf: Anki_Vector_ExternalInterface_PathMotionProfile {
    get {return _motionProf ?? Anki_Vector_ExternalInterface_PathMotionProfile()}
    set {_motionProf = newValue}
  }
  /// Returns true if `motionProf` has been explicitly set.
  public var hasMotionProf: Bool {return self._motionProf != nil}
  /// Clears the value of `motionProf`. Subsequent reads from it will return its default value.
  public mutating func clearMotionProf() {self._motionProf = nil}

  public var idTag: Int32 = 0

  public var numRetries: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _motionProf: Anki_Vector_ExternalInterface_PathMotionProfile? = nil
}

public struct Anki_Vector_ExternalInterface_GoToPoseResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_ActionResult {
    get {return _result ?? Anki_Vector_ExternalInterface_ActionResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
  fileprivate var _result: Anki_Vector_ExternalInterface_ActionResult? = nil
}

public struct Anki_Vector_ExternalInterface_DockWithCubeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var objectID: Int32 {
    get {return _storage._objectID}
    set {_uniqueStorage()._objectID = newValue}
  }

  public var distanceFromMarkerMm: Float {
    get {return _storage._distanceFromMarkerMm}
    set {_uniqueStorage()._distanceFromMarkerMm = newValue}
  }

  public var approachAngleRad: Float {
    get {return _storage._approachAngleRad}
    set {_uniqueStorage()._approachAngleRad = newValue}
  }

  public var alignmentType: Anki_Vector_ExternalInterface_AlignmentType {
    get {return _storage._alignmentType}
    set {_uniqueStorage()._alignmentType = newValue}
  }

  public var useApproachAngle: Bool {
    get {return _storage._useApproachAngle}
    set {_uniqueStorage()._useApproachAngle = newValue}
  }

  public var usePreDockPose: Bool {
    get {return _storage._usePreDockPose}
    set {_uniqueStorage()._usePreDockPose = newValue}
  }

  public var motionProf: Anki_Vector_ExternalInterface_PathMotionProfile {
    get {return _storage._motionProf ?? Anki_Vector_ExternalInterface_PathMotionProfile()}
    set {_uniqueStorage()._motionProf = newValue}
  }
  /// Returns true if `motionProf` has been explicitly set.
  public var hasMotionProf: Bool {return _storage._motionProf != nil}
  /// Clears the value of `motionProf`. Subsequent reads from it will return its default value.
  public mutating func clearMotionProf() {_uniqueStorage()._motionProf = nil}

  public var idTag: Int32 {
    get {return _storage._idTag}
    set {_uniqueStorage()._idTag = newValue}
  }

  public var numRetries: Int32 {
    get {return _storage._numRetries}
    set {_uniqueStorage()._numRetries = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Anki_Vector_ExternalInterface_DockWithCubeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_ActionResult {
    get {return _result ?? Anki_Vector_ExternalInterface_ActionResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
  fileprivate var _result: Anki_Vector_ExternalInterface_ActionResult? = nil
}

public struct Anki_Vector_ExternalInterface_DriveStraightRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Speed should be positive
  public var speedMmps: Float = 0

  /// Use +ve for forward, -ve for backward
  public var distMm: Float = 0

  public var shouldPlayAnimation: Bool = false

  public var idTag: Int32 = 0

  public var numRetries: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_DriveStraightResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_ActionResult {
    get {return _result ?? Anki_Vector_ExternalInterface_ActionResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
  fileprivate var _result: Anki_Vector_ExternalInterface_ActionResult? = nil
}

/// TurnInPlace
/// If isAbsolute == 0, turns the specified number of radians, relative to the robot's current heading*
/// If isAbsolute != 0, turns to the specified absolute orientation.
public struct Anki_Vector_ExternalInterface_TurnInPlaceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// relative mode: positive turns left negative turns right
  public var angleRad: Float = 0

  public var speedRadPerSec: Float = 0

  public var accelRadPerSec2: Float = 0

  /// This should be no smaller than POINT_TURN_ANGLE_TOL (DEG_TO_RAD(2.f)).
  public var tolRad: Float = 0

  /// Smaller values are ignored except 0 which is interpreted to mean
  /// default tolerance of POINT_TURN_ANGLE_TOL.
  public var isAbsolute: UInt32 = 0

  public var idTag: Int32 = 0

  public var numRetries: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_TurnInPlaceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_ActionResult {
    get {return _result ?? Anki_Vector_ExternalInterface_ActionResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
  fileprivate var _result: Anki_Vector_ExternalInterface_ActionResult? = nil
}

/// SetHeadAngle
public struct Anki_Vector_ExternalInterface_SetHeadAngleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var angleRad: Float = 0

  public var maxSpeedRadPerSec: Float = 0

  public var accelRadPerSec2: Float = 0

  public var durationSec: Float = 0

  public var idTag: Int32 = 0

  public var numRetries: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_SetHeadAngleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_ActionResult {
    get {return _result ?? Anki_Vector_ExternalInterface_ActionResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
  fileprivate var _result: Anki_Vector_ExternalInterface_ActionResult? = nil
}

/// SetLiftHeight
public struct Anki_Vector_ExternalInterface_SetLiftHeightRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var heightMm: Float = 0

  public var maxSpeedRadPerSec: Float = 0

  public var accelRadPerSec2: Float = 0

  public var durationSec: Float = 0

  public var idTag: Int32 = 0

  public var numRetries: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_SetLiftHeightResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_ActionResult {
    get {return _result ?? Anki_Vector_ExternalInterface_ActionResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
  fileprivate var _result: Anki_Vector_ExternalInterface_ActionResult? = nil
}

/// TurnTowardsFace
public struct Anki_Vector_ExternalInterface_TurnTowardsFaceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var faceID: Int32 = 0

  public var maxTurnAngleRad: Float = 0

  public var idTag: Int32 = 0

  public var numRetries: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_TurnTowardsFaceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_ActionResult {
    get {return _result ?? Anki_Vector_ExternalInterface_ActionResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
  fileprivate var _result: Anki_Vector_ExternalInterface_ActionResult? = nil
}

/// GoToObject
public struct Anki_Vector_ExternalInterface_GoToObjectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var objectID: Int32 = 0

  public var motionProf: Anki_Vector_ExternalInterface_PathMotionProfile {
    get {return _motionProf ?? Anki_Vector_ExternalInterface_PathMotionProfile()}
    set {_motionProf = newValue}
  }
  /// Returns true if `motionProf` has been explicitly set.
  public var hasMotionProf: Bool {return self._motionProf != nil}
  /// Clears the value of `motionProf`. Subsequent reads from it will return its default value.
  public mutating func clearMotionProf() {self._motionProf = nil}

  public var distanceFromObjectOriginMm: Float = 0

  public var usePreDockPose: Bool = false

  public var idTag: Int32 = 0

  public var numRetries: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _motionProf: Anki_Vector_ExternalInterface_PathMotionProfile? = nil
}

public struct Anki_Vector_ExternalInterface_GoToObjectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_ActionResult {
    get {return _result ?? Anki_Vector_ExternalInterface_ActionResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
  fileprivate var _result: Anki_Vector_ExternalInterface_ActionResult? = nil
}

/// RollObject
public struct Anki_Vector_ExternalInterface_RollObjectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// negative value means "currently selected object"
  public var objectID: Int32 {
    get {return _storage._objectID}
    set {_uniqueStorage()._objectID = newValue}
  }

  public var motionProf: Anki_Vector_ExternalInterface_PathMotionProfile {
    get {return _storage._motionProf ?? Anki_Vector_ExternalInterface_PathMotionProfile()}
    set {_uniqueStorage()._motionProf = newValue}
  }
  /// Returns true if `motionProf` has been explicitly set.
  public var hasMotionProf: Bool {return _storage._motionProf != nil}
  /// Clears the value of `motionProf`. Subsequent reads from it will return its default value.
  public mutating func clearMotionProf() {_uniqueStorage()._motionProf = nil}

  public var approachAngleRad: Float {
    get {return _storage._approachAngleRad}
    set {_uniqueStorage()._approachAngleRad = newValue}
  }

  public var useApproachAngle: Bool {
    get {return _storage._useApproachAngle}
    set {_uniqueStorage()._useApproachAngle = newValue}
  }

  public var usePreDockPose: Bool {
    get {return _storage._usePreDockPose}
    set {_uniqueStorage()._usePreDockPose = newValue}
  }

  public var idTag: Int32 {
    get {return _storage._idTag}
    set {_uniqueStorage()._idTag = newValue}
  }

  public var numRetries: Int32 {
    get {return _storage._numRetries}
    set {_uniqueStorage()._numRetries = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Anki_Vector_ExternalInterface_RollObjectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_ActionResult {
    get {return _result ?? Anki_Vector_ExternalInterface_ActionResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
  fileprivate var _result: Anki_Vector_ExternalInterface_ActionResult? = nil
}

/// PopAWheelie
public struct Anki_Vector_ExternalInterface_PopAWheelieRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// negative value means "currently selected object"
  public var objectID: Int32 {
    get {return _storage._objectID}
    set {_uniqueStorage()._objectID = newValue}
  }

  public var motionProf: Anki_Vector_ExternalInterface_PathMotionProfile {
    get {return _storage._motionProf ?? Anki_Vector_ExternalInterface_PathMotionProfile()}
    set {_uniqueStorage()._motionProf = newValue}
  }
  /// Returns true if `motionProf` has been explicitly set.
  public var hasMotionProf: Bool {return _storage._motionProf != nil}
  /// Clears the value of `motionProf`. Subsequent reads from it will return its default value.
  public mutating func clearMotionProf() {_uniqueStorage()._motionProf = nil}

  public var approachAngleRad: Float {
    get {return _storage._approachAngleRad}
    set {_uniqueStorage()._approachAngleRad = newValue}
  }

  public var useApproachAngle: Bool {
    get {return _storage._useApproachAngle}
    set {_uniqueStorage()._useApproachAngle = newValue}
  }

  public var usePreDockPose: Bool {
    get {return _storage._usePreDockPose}
    set {_uniqueStorage()._usePreDockPose = newValue}
  }

  public var idTag: Int32 {
    get {return _storage._idTag}
    set {_uniqueStorage()._idTag = newValue}
  }

  public var numRetries: Int32 {
    get {return _storage._numRetries}
    set {_uniqueStorage()._numRetries = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Anki_Vector_ExternalInterface_PopAWheelieResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_ActionResult {
    get {return _result ?? Anki_Vector_ExternalInterface_ActionResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
  fileprivate var _result: Anki_Vector_ExternalInterface_ActionResult? = nil
}

/// PickupObject
public struct Anki_Vector_ExternalInterface_PickupObjectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// negative value means "currently selected object"
  public var objectID: Int32 {
    get {return _storage._objectID}
    set {_uniqueStorage()._objectID = newValue}
  }

  public var motionProf: Anki_Vector_ExternalInterface_PathMotionProfile {
    get {return _storage._motionProf ?? Anki_Vector_ExternalInterface_PathMotionProfile()}
    set {_uniqueStorage()._motionProf = newValue}
  }
  /// Returns true if `motionProf` has been explicitly set.
  public var hasMotionProf: Bool {return _storage._motionProf != nil}
  /// Clears the value of `motionProf`. Subsequent reads from it will return its default value.
  public mutating func clearMotionProf() {_uniqueStorage()._motionProf = nil}

  public var approachAngleRad: Float {
    get {return _storage._approachAngleRad}
    set {_uniqueStorage()._approachAngleRad = newValue}
  }

  public var useApproachAngle: Bool {
    get {return _storage._useApproachAngle}
    set {_uniqueStorage()._useApproachAngle = newValue}
  }

  public var usePreDockPose: Bool {
    get {return _storage._usePreDockPose}
    set {_uniqueStorage()._usePreDockPose = newValue}
  }

  public var idTag: Int32 {
    get {return _storage._idTag}
    set {_uniqueStorage()._idTag = newValue}
  }

  public var numRetries: Int32 {
    get {return _storage._numRetries}
    set {_uniqueStorage()._numRetries = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Anki_Vector_ExternalInterface_PickupObjectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_ActionResult {
    get {return _result ?? Anki_Vector_ExternalInterface_ActionResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
  fileprivate var _result: Anki_Vector_ExternalInterface_ActionResult? = nil
}

/// PlaceObjectOnGroundHere
public struct Anki_Vector_ExternalInterface_PlaceObjectOnGroundHereRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idTag: Int32 = 0

  public var numRetries: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_PlaceObjectOnGroundHereResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var result: Anki_Vector_ExternalInterface_ActionResult {
    get {return _result ?? Anki_Vector_ExternalInterface_ActionResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
  fileprivate var _result: Anki_Vector_ExternalInterface_ActionResult? = nil
}

public struct Anki_Vector_ExternalInterface_BatteryStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_BatteryStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var batteryLevel: Anki_Vector_ExternalInterface_BatteryLevel = .unknown

  public var batteryVolts: Float = 0

  public var isCharging: Bool = false

  public var isOnChargerPlatform: Bool = false

  public var suggestedChargerSec: Float = 0

  public var cubeBattery: Anki_Vector_ExternalInterface_CubeBattery {
    get {return _cubeBattery ?? Anki_Vector_ExternalInterface_CubeBattery()}
    set {_cubeBattery = newValue}
  }
  /// Returns true if `cubeBattery` has been explicitly set.
  public var hasCubeBattery: Bool {return self._cubeBattery != nil}
  /// Clears the value of `cubeBattery`. Subsequent reads from it will return its default value.
  public mutating func clearCubeBattery() {self._cubeBattery = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
  fileprivate var _cubeBattery: Anki_Vector_ExternalInterface_CubeBattery? = nil
}

public struct Anki_Vector_ExternalInterface_CubeBattery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var level: Anki_Vector_ExternalInterface_CubeBattery.CubeBatteryLevel = .low

  public var factoryID: String = String()

  public var batteryVolts: Float = 0

  public var timeSinceLastReadingSec: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum CubeBatteryLevel: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case low // = 0
    case normal // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .low
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .low
      case 1: self = .normal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .low: return 0
      case .normal: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_CubeBattery.CubeBatteryLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_CubeBattery.CubeBatteryLevel] = [
    .low,
    .normal,
  ]
}

#endif  // swift(>=4.2)

public struct Anki_Vector_ExternalInterface_VersionStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_VersionStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var osVersion: String = String()

  public var engineBuildID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_SayTextRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var useVectorVoice: Bool = false

  public var durationScalar: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_SayTextResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var state: Anki_Vector_ExternalInterface_SayTextResponse.UtteranceState = .invalid

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum UtteranceState: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case invalid // = 0
    case generating // = 1
    case ready // = 2
    case playing // = 3
    case finished // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .invalid
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .invalid
      case 1: self = .generating
      case 2: self = .ready
      case 3: self = .playing
      case 4: self = .finished
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .invalid: return 0
      case .generating: return 1
      case .ready: return 2
      case .playing: return 3
      case .finished: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_SayTextResponse.UtteranceState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_SayTextResponse.UtteranceState] = [
    .invalid,
    .generating,
    .ready,
    .playing,
    .finished,
  ]
}

#endif  // swift(>=4.2)

public struct Anki_Vector_ExternalInterface_StimulationInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// may be empty
  public var emotionEvents: [String] = []

  public var value: Float = 0

  /// value per second
  public var velocity: Float = 0

  /// value per sec per sec
  public var accel: Float = 0

  /// matches value if there were no emotion events
  public var valueBeforeEvent: Float = 0

  public var minValue: Float = 0

  public var maxValue: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request how the robot should process and send audio
public struct Anki_Vector_ExternalInterface_AudioSendModeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: Anki_Vector_ExternalInterface_AudioProcessingMode = .audioUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Event sent when the robot changes the mode it's processing and sending audio
public struct Anki_Vector_ExternalInterface_AudioSendModeChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: Anki_Vector_ExternalInterface_AudioProcessingMode = .audioUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// One frame of robot audio data and associated metadata
public struct Anki_Vector_ExternalInterface_AudioChunk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// robot time at the final chunk of this audio sample group transmission
  public var robotTimeStamp: UInt32 = 0

  /// the id of this sample transmission group
  public var groupID: UInt32 = 0

  /// the current batched chunk id within in this group id
  public var chunkID: UInt32 = 0

  /// number of chunks batched within this group id
  public var audioChunkCount: UInt32 = 0

  /// mono audio amplitude samples
  public var signalPower: Data = Data()

  /// histogram data of which directions this audio chunk came from
  public var directionStrengths: Data = Data()

  /// 0-11, with 12 representing "invalid"
  public var sourceDirection: UInt32 = 0

  /// accuracy of the calculated source_direction
  public var sourceConfidence: UInt32 = 0

  /// power value, convert to db with log_10(value)
  public var noiseFloorPower: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request the robot to send audio data
public struct Anki_Vector_ExternalInterface_AudioFeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Streamed audio data from the robot
public struct Anki_Vector_ExternalInterface_AudioFeedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// robot time at the transmission of this audio sample group
  public var robotTimeStamp: UInt32 = 0

  /// the index of this audio feed response
  public var groupID: UInt32 = 0

  /// mono audio amplitude samples
  public var signalPower: Data = Data()

  /// histogram data of which directions this audio chunk came from
  public var directionStrengths: Data = Data()

  /// 0-11, with 12 representing "invalid"
  public var sourceDirection: UInt32 = 0

  /// accuracy of the calculated source_direction
  public var sourceConfidence: UInt32 = 0

  /// power value, convert to db with log_10(value)
  public var noiseFloorPower: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Preflight and initialization for audio streaming to robot
public struct Anki_Vector_ExternalInterface_ExternalAudioStreamPrepare {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 8000 - 16025
  public var audioFrameRate: UInt32 = 0

  /// 0 - 100
  public var audioVolume: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Send chunk of audio data to stream on robot
public struct Anki_Vector_ExternalInterface_ExternalAudioStreamChunk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///current engine maximum of 1024 bytes
  public var audioChunkSizeBytes: UInt32 = 0

  ///16-bit little-endian PCM audio data
  public var audioChunkSamples: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Send notification of last chunk of audio sent to robot
public struct Anki_Vector_ExternalInterface_ExternalAudioStreamComplete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Cancel a playing external robot audio stream
public struct Anki_Vector_ExternalInterface_ExternalAudioStreamCancel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to stream audio to the robot
public struct Anki_Vector_ExternalInterface_ExternalAudioStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var audioRequestType: Anki_Vector_ExternalInterface_ExternalAudioStreamRequest.OneOf_AudioRequestType? = nil

  public var audioStreamPrepare: Anki_Vector_ExternalInterface_ExternalAudioStreamPrepare {
    get {
      if case .audioStreamPrepare(let v)? = audioRequestType {return v}
      return Anki_Vector_ExternalInterface_ExternalAudioStreamPrepare()
    }
    set {audioRequestType = .audioStreamPrepare(newValue)}
  }

  public var audioStreamChunk: Anki_Vector_ExternalInterface_ExternalAudioStreamChunk {
    get {
      if case .audioStreamChunk(let v)? = audioRequestType {return v}
      return Anki_Vector_ExternalInterface_ExternalAudioStreamChunk()
    }
    set {audioRequestType = .audioStreamChunk(newValue)}
  }

  public var audioStreamComplete: Anki_Vector_ExternalInterface_ExternalAudioStreamComplete {
    get {
      if case .audioStreamComplete(let v)? = audioRequestType {return v}
      return Anki_Vector_ExternalInterface_ExternalAudioStreamComplete()
    }
    set {audioRequestType = .audioStreamComplete(newValue)}
  }

  public var audioStreamCancel: Anki_Vector_ExternalInterface_ExternalAudioStreamCancel {
    get {
      if case .audioStreamCancel(let v)? = audioRequestType {return v}
      return Anki_Vector_ExternalInterface_ExternalAudioStreamCancel()
    }
    set {audioRequestType = .audioStreamCancel(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_AudioRequestType: Equatable {
    case audioStreamPrepare(Anki_Vector_ExternalInterface_ExternalAudioStreamPrepare)
    case audioStreamChunk(Anki_Vector_ExternalInterface_ExternalAudioStreamChunk)
    case audioStreamComplete(Anki_Vector_ExternalInterface_ExternalAudioStreamComplete)
    case audioStreamCancel(Anki_Vector_ExternalInterface_ExternalAudioStreamCancel)

  #if !swift(>=4.1)
    public static func ==(lhs: Anki_Vector_ExternalInterface_ExternalAudioStreamRequest.OneOf_AudioRequestType, rhs: Anki_Vector_ExternalInterface_ExternalAudioStreamRequest.OneOf_AudioRequestType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.audioStreamPrepare, .audioStreamPrepare): return {
        guard case .audioStreamPrepare(let l) = lhs, case .audioStreamPrepare(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audioStreamChunk, .audioStreamChunk): return {
        guard case .audioStreamChunk(let l) = lhs, case .audioStreamChunk(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audioStreamComplete, .audioStreamComplete): return {
        guard case .audioStreamComplete(let l) = lhs, case .audioStreamComplete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audioStreamCancel, .audioStreamCancel): return {
        guard case .audioStreamCancel(let l) = lhs, case .audioStreamCancel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Audio has been played on the Robot
public struct Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackComplete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Audio playback failure
public struct Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackFailure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Audio has been sent to robot that would overrun the memory buffer
public struct Anki_Vector_ExternalInterface_ExternalAudioStreamBufferOverrun {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var audioSamplesSent: UInt32 = 0

  public var audioSamplesPlayed: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from streaming audio to robot
public struct Anki_Vector_ExternalInterface_ExternalAudioStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var audioResponseType: Anki_Vector_ExternalInterface_ExternalAudioStreamResponse.OneOf_AudioResponseType? = nil

  public var audioStreamPlaybackComplete: Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackComplete {
    get {
      if case .audioStreamPlaybackComplete(let v)? = audioResponseType {return v}
      return Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackComplete()
    }
    set {audioResponseType = .audioStreamPlaybackComplete(newValue)}
  }

  public var audioStreamBufferOverrun: Anki_Vector_ExternalInterface_ExternalAudioStreamBufferOverrun {
    get {
      if case .audioStreamBufferOverrun(let v)? = audioResponseType {return v}
      return Anki_Vector_ExternalInterface_ExternalAudioStreamBufferOverrun()
    }
    set {audioResponseType = .audioStreamBufferOverrun(newValue)}
  }

  public var audioStreamPlaybackFailyer: Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackFailure {
    get {
      if case .audioStreamPlaybackFailyer(let v)? = audioResponseType {return v}
      return Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackFailure()
    }
    set {audioResponseType = .audioStreamPlaybackFailyer(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_AudioResponseType: Equatable {
    case audioStreamPlaybackComplete(Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackComplete)
    case audioStreamBufferOverrun(Anki_Vector_ExternalInterface_ExternalAudioStreamBufferOverrun)
    case audioStreamPlaybackFailyer(Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackFailure)

  #if !swift(>=4.1)
    public static func ==(lhs: Anki_Vector_ExternalInterface_ExternalAudioStreamResponse.OneOf_AudioResponseType, rhs: Anki_Vector_ExternalInterface_ExternalAudioStreamResponse.OneOf_AudioResponseType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.audioStreamPlaybackComplete, .audioStreamPlaybackComplete): return {
        guard case .audioStreamPlaybackComplete(let l) = lhs, case .audioStreamPlaybackComplete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audioStreamBufferOverrun, .audioStreamBufferOverrun): return {
        guard case .audioStreamBufferOverrun(let l) = lhs, case .audioStreamBufferOverrun(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audioStreamPlaybackFailyer, .audioStreamPlaybackFailyer): return {
        guard case .audioStreamPlaybackFailyer(let l) = lhs, case .audioStreamPlaybackFailyer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Anki_Vector_ExternalInterface_MasterVolumeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var volumeLevel: Anki_Vector_ExternalInterface_MasterVolumeLevel = .volumeLow

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_MasterVolumeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// When enabled, RobotObservedObject messages will be produced
public struct Anki_Vector_ExternalInterface_EnableMarkerDetectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_EnableMarkerDetectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// When enabled, RobotObservedFace messages will be produced
public struct Anki_Vector_ExternalInterface_EnableFaceDetectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enable: Bool = false

  public var enableSmileDetection: Bool = false

  public var enableExpressionEstimation: Bool = false

  public var enableBlinkDetection: Bool = false

  public var enableGazeDetection: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_EnableFaceDetectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// When enabled, RobotObservedMotion messages will be produced
public struct Anki_Vector_ExternalInterface_EnableMotionDetectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_EnableMotionDetectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// When enabled, camera feed will appear on the robot's face, along with any 
/// detections that are enabled from above messages
public struct Anki_Vector_ExternalInterface_EnableMirrorModeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_EnableMirrorModeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// Sent if MirrorMode (camera feed displayed on face) is currently enabled but is automatically
/// being disabled
public struct Anki_Vector_ExternalInterface_MirrorModeDisabled {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Toggle image streaming at the given resolution
public struct Anki_Vector_ExternalInterface_EnableImageStreamingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_EnableImageStreamingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// Request whether or not image streaming is enabled on the robot
public struct Anki_Vector_ExternalInterface_IsImageStreamingEnabledRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Indicates whether or not image streaming is enabled on the robot
public struct Anki_Vector_ExternalInterface_IsImageStreamingEnabledResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isImageStreamingEnabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Sent when vision modes are automatically disabled due to the SDK no longer having control
/// of the robot
public struct Anki_Vector_ExternalInterface_VisionModesAutoDisabled {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// One frame of image data and associated metadata
public struct Anki_Vector_ExternalInterface_ImageChunk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var frameTimeStamp: UInt32 = 0

  public var imageID: UInt32 = 0

  public var width: UInt32 = 0

  public var height: UInt32 = 0

  public var imageEncoding: Anki_Vector_ExternalInterface_ImageChunk.ImageEncoding = .noneImageEncoding

  public var displayIndex: UInt32 = 0

  public var imageChunkCount: UInt32 = 0

  public var chunkID: UInt32 = 0

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ImageEncoding: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case noneImageEncoding // = 0

    /// no compression
    case rawGray // = 1

    /// no compression, just [RGBRGBRG...]
    case rawRgb // = 2
    case yuyv // = 3
    case yuv420Sp // = 4
    case bayer // = 5
    case jpegGray // = 6
    case jpegColor // = 7
    case jpegColorHalfWidth // = 8

    /// Minimized grayscale JPEG - no header, no footer, no byte stuffing
    case jpegMinimizedGray // = 9

    /// Minimized grayscale JPEG - no header, no footer, no byte stuffing, with added color data
    case jpegMinimizedColor // = 10
    case UNRECOGNIZED(Int)

    public init() {
      self = .noneImageEncoding
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noneImageEncoding
      case 1: self = .rawGray
      case 2: self = .rawRgb
      case 3: self = .yuyv
      case 4: self = .yuv420Sp
      case 5: self = .bayer
      case 6: self = .jpegGray
      case 7: self = .jpegColor
      case 8: self = .jpegColorHalfWidth
      case 9: self = .jpegMinimizedGray
      case 10: self = .jpegMinimizedColor
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .noneImageEncoding: return 0
      case .rawGray: return 1
      case .rawRgb: return 2
      case .yuyv: return 3
      case .yuv420Sp: return 4
      case .bayer: return 5
      case .jpegGray: return 6
      case .jpegColor: return 7
      case .jpegColorHalfWidth: return 8
      case .jpegMinimizedGray: return 9
      case .jpegMinimizedColor: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_ImageChunk.ImageEncoding: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_ImageChunk.ImageEncoding] = [
    .noneImageEncoding,
    .rawGray,
    .rawRgb,
    .yuyv,
    .yuv420Sp,
    .bayer,
    .jpegGray,
    .jpegColor,
    .jpegColorHalfWidth,
    .jpegMinimizedGray,
    .jpegMinimizedColor,
  ]
}

#endif  // swift(>=4.2)

public struct Anki_Vector_ExternalInterface_CameraFeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_CameraFeedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var frameTimeStamp: UInt32 = 0

  public var imageID: UInt32 = 0

  public var imageEncoding: Anki_Vector_ExternalInterface_ImageChunk.ImageEncoding = .noneImageEncoding

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_CaptureSingleImageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_CaptureSingleImageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var frameTimeStamp: UInt32 = 0

  public var imageID: UInt32 = 0

  public var imageEncoding: Anki_Vector_ExternalInterface_ImageChunk.ImageEncoding = .noneImageEncoding

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_SetEyeColorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hue: Float = 0

  public var saturation: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_SetEyeColorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_SDKInitializationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sdkModuleVersion: String = String()

  public var pythonVersion: String = String()

  public var pythonImplementation: String = String()

  public var osVersion: String = String()

  public var cpuVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_SDKInitializationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Anki_Vector_ExternalInterface_RobotStatus: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_FacialExpression: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_FaceEnrollmentResult: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_BehaviorResults: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ActionTagConstants: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_AlignmentType: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_BatteryLevel: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_AudioConstants: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_AudioProcessingMode: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_MasterVolumeLevel: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_KeepAlivePing: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_AnimationTrigger: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_Animation: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DriveWheelsRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DriveWheelsResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_MoveHeadRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_MoveHeadResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_MoveLiftRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_MoveLiftResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_StopAllMotorsRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_StopAllMotorsResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PlayAnimationTriggerRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PlayAnimationRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PlayAnimationResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ListAnimationsRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ListAnimationsResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ListAnimationTriggersRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ListAnimationTriggersResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DisplayFaceImageRGBRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DisplayFaceImageRGBResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_MeetVictorFaceScanStarted: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_MeetVictorFaceScanComplete: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_Status: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_Status.OneOf_StatusType: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_WakeWord: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_WakeWord.OneOf_WakeWordType: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_TimeStampedStatus: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PoseStruct: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_AccelData: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_GyroData: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ProxData: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_TouchData: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_RobotState: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CladPoint: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CladRect: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_RobotObservedFace: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_RobotChangedObservedFaceID: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_FaceEnrollmentCompleted: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CancelFaceEnrollmentRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CancelFaceEnrollmentResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_RequestEnrolledNamesRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_LoadedKnownFace: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_RobotRenamedEnrolledFace: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_RequestEnrolledNamesResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_UpdateEnrolledFaceByIDRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_UpdateEnrolledFaceByIDResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_EraseEnrolledFaceByIDRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_EraseEnrolledFaceByIDResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_EraseAllEnrolledFacesRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_EraseAllEnrolledFacesResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SetFaceToEnrollRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SetFaceToEnrollResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DriveOffChargerRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DriveOffChargerResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DriveOnChargerRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DriveOnChargerResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_FindFacesRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_FindFacesResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_LookAroundInPlaceRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_LookAroundInPlaceResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_RollBlockRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_RollBlockResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_WakeWordBegin: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_WakeWordEnd: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_UserIntent: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PhotoInfo: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PhotosInfoRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PhotosInfoResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PhotoRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PhotoPathMessage: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PhotoResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ThumbnailRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ThumbnailPathMessage: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ThumbnailResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DeletePhotoRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DeletePhotoResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PhotoTaken: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PathMotionProfile: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ActionResult: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ActionResult.ActionResultCode: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CancelActionByIdTagRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CancelActionByIdTagResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_GoToPoseRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_GoToPoseResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DockWithCubeRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DockWithCubeResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DriveStraightRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DriveStraightResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_TurnInPlaceRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_TurnInPlaceResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SetHeadAngleRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SetHeadAngleResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SetLiftHeightRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SetLiftHeightResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_TurnTowardsFaceRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_TurnTowardsFaceResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_GoToObjectRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_GoToObjectResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_RollObjectRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_RollObjectResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PopAWheelieRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PopAWheelieResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PickupObjectRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PickupObjectResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PlaceObjectOnGroundHereRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_PlaceObjectOnGroundHereResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_BatteryStateRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_BatteryStateResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CubeBattery: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CubeBattery.CubeBatteryLevel: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_VersionStateRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_VersionStateResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SayTextRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SayTextResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SayTextResponse.UtteranceState: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_StimulationInfo: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_AudioSendModeRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_AudioSendModeChanged: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_AudioChunk: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_AudioFeedRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_AudioFeedResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ExternalAudioStreamPrepare: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ExternalAudioStreamChunk: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ExternalAudioStreamComplete: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ExternalAudioStreamCancel: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ExternalAudioStreamRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ExternalAudioStreamRequest.OneOf_AudioRequestType: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackComplete: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackFailure: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ExternalAudioStreamBufferOverrun: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ExternalAudioStreamResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ExternalAudioStreamResponse.OneOf_AudioResponseType: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_MasterVolumeRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_MasterVolumeResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_EnableMarkerDetectionRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_EnableMarkerDetectionResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_EnableFaceDetectionRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_EnableFaceDetectionResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_EnableMotionDetectionRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_EnableMotionDetectionResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_EnableMirrorModeRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_EnableMirrorModeResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_MirrorModeDisabled: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_EnableImageStreamingRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_EnableImageStreamingResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_IsImageStreamingEnabledRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_IsImageStreamingEnabledResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_VisionModesAutoDisabled: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ImageChunk: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ImageChunk.ImageEncoding: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CameraFeedRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CameraFeedResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CaptureSingleImageRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CaptureSingleImageResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SetEyeColorRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SetEyeColorResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SDKInitializationRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SDKInitializationResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "Anki.Vector.external_interface"

extension Anki_Vector_ExternalInterface_RobotStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ROBOT_STATUS_NONE"),
    1: .same(proto: "ROBOT_STATUS_IS_MOVING"),
    2: .same(proto: "ROBOT_STATUS_IS_CARRYING_BLOCK"),
    4: .same(proto: "ROBOT_STATUS_IS_PICKING_OR_PLACING"),
    8: .same(proto: "ROBOT_STATUS_IS_PICKED_UP"),
    16: .same(proto: "ROBOT_STATUS_IS_BUTTON_PRESSED"),
    32: .same(proto: "ROBOT_STATUS_IS_FALLING"),
    64: .same(proto: "ROBOT_STATUS_IS_ANIMATING"),
    128: .same(proto: "ROBOT_STATUS_IS_PATHING"),
    256: .same(proto: "ROBOT_STATUS_LIFT_IN_POS"),
    512: .same(proto: "ROBOT_STATUS_HEAD_IN_POS"),
    1024: .same(proto: "ROBOT_STATUS_CALM_POWER_MODE"),
    4096: .same(proto: "ROBOT_STATUS_IS_ON_CHARGER"),
    8192: .same(proto: "ROBOT_STATUS_IS_CHARGING"),
    16384: .same(proto: "ROBOT_STATUS_CLIFF_DETECTED"),
    32768: .same(proto: "ROBOT_STATUS_ARE_WHEELS_MOVING"),
    65536: .same(proto: "ROBOT_STATUS_IS_BEING_HELD"),
    131072: .same(proto: "ROBOT_STATUS_IS_MOTION_DETECTED"),
  ]
}

extension Anki_Vector_ExternalInterface_FacialExpression: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXPRESSION_UNKNOWN"),
    1: .same(proto: "EXPRESSION_NEUTRAL"),
    2: .same(proto: "EXPRESSION_HAPPINESS"),
    3: .same(proto: "EXPRESSION_SURPRISE"),
    4: .same(proto: "EXPRESSION_ANGER"),
    5: .aliased(proto: "EXPRESSION_SADNESS", aliases: ["EXPRESSION_COUNT"]),
  ]
}

extension Anki_Vector_ExternalInterface_FaceEnrollmentResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCCESS"),
    1: .same(proto: "SAW_WRONG_FACE"),
    2: .same(proto: "SAW_MULTIPLE_FACES"),
    3: .same(proto: "TIMED_OUT"),
    4: .same(proto: "SAVE_FAILED"),
    5: .same(proto: "INCOMPLETE"),
    6: .same(proto: "CANCELLED"),
    7: .same(proto: "NAME_IN_USE"),
    8: .same(proto: "NAMED_STORAGE_FULL"),
    9: .same(proto: "UNKNOWN_FAILURE"),
  ]
}

extension Anki_Vector_ExternalInterface_BehaviorResults: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BEHAVIOR_INVALID_STATE"),
    1: .same(proto: "BEHAVIOR_COMPLETE_STATE"),
    2: .same(proto: "BEHAVIOR_WONT_ACTIVATE_STATE"),
  ]
}

extension Anki_Vector_ExternalInterface_ActionTagConstants: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_SDK_TAG"),
    2000001: .same(proto: "FIRST_SDK_TAG"),
    3000000: .same(proto: "LAST_SDK_TAG"),
  ]
}

extension Anki_Vector_ExternalInterface_AlignmentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALIGNMENT_TYPE_UNKNOWN"),
    1: .same(proto: "ALIGNMENT_TYPE_LIFT_FINGER"),
    2: .same(proto: "ALIGNMENT_TYPE_LIFT_PLATE"),
    3: .same(proto: "ALIGNMENT_TYPE_BODY"),
    4: .same(proto: "ALIGNMENT_TYPE_CUSTOM"),
  ]
}

extension Anki_Vector_ExternalInterface_BatteryLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BATTERY_LEVEL_UNKNOWN"),
    1: .same(proto: "BATTERY_LEVEL_LOW"),
    2: .same(proto: "BATTERY_LEVEL_NOMINAL"),
    3: .same(proto: "BATTERY_LEVEL_FULL"),
  ]
}

extension Anki_Vector_ExternalInterface_AudioConstants: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUDIO_CONSTANTS_NULL"),
    12: .same(proto: "MIC_DETECTION_DIRECTIONS"),
    160: .same(proto: "SAMPLE_COUNTS_PER_ENGINE_MESSAGE"),
    1600: .same(proto: "SAMPLE_COUNTS_PER_SDK_MESSAGE"),
    15625: .same(proto: "MICROPHONE_SAMPLE_RATE"),
    16000: .same(proto: "PROCESSED_SAMPLE_RATE"),
  ]
}

extension Anki_Vector_ExternalInterface_AudioProcessingMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUDIO_UNKNOWN"),
    1: .same(proto: "AUDIO_OFF"),
    2: .same(proto: "AUDIO_FAST_MODE"),
    3: .same(proto: "AUDIO_DIRECTIONAL_MODE"),
    4: .same(proto: "AUDIO_VOICE_DETECT_MODE"),
  ]
}

extension Anki_Vector_ExternalInterface_MasterVolumeLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOLUME_LOW"),
    1: .same(proto: "VOLUME_MEDIUM_LOW"),
    2: .same(proto: "VOLUME_MEDIUM"),
    3: .same(proto: "VOLUME_MEDIUM_HIGH"),
    4: .same(proto: "VOLUME_HIGH"),
  ]
}

extension Anki_Vector_ExternalInterface_KeepAlivePing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeepAlivePing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_KeepAlivePing, rhs: Anki_Vector_ExternalInterface_KeepAlivePing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_AnimationTrigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnimationTrigger"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_AnimationTrigger, rhs: Anki_Vector_ExternalInterface_AnimationTrigger) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_Animation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Animation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_Animation, rhs: Anki_Vector_ExternalInterface_Animation) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DriveWheelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DriveWheelsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "left_wheel_mmps"),
    2: .standard(proto: "right_wheel_mmps"),
    3: .standard(proto: "left_wheel_mmps2"),
    4: .standard(proto: "right_wheel_mmps2"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.leftWheelMmps) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.rightWheelMmps) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.leftWheelMmps2) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.rightWheelMmps2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.leftWheelMmps != 0 {
      try visitor.visitSingularFloatField(value: self.leftWheelMmps, fieldNumber: 1)
    }
    if self.rightWheelMmps != 0 {
      try visitor.visitSingularFloatField(value: self.rightWheelMmps, fieldNumber: 2)
    }
    if self.leftWheelMmps2 != 0 {
      try visitor.visitSingularFloatField(value: self.leftWheelMmps2, fieldNumber: 3)
    }
    if self.rightWheelMmps2 != 0 {
      try visitor.visitSingularFloatField(value: self.rightWheelMmps2, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DriveWheelsRequest, rhs: Anki_Vector_ExternalInterface_DriveWheelsRequest) -> Bool {
    if lhs.leftWheelMmps != rhs.leftWheelMmps {return false}
    if lhs.rightWheelMmps != rhs.rightWheelMmps {return false}
    if lhs.leftWheelMmps2 != rhs.leftWheelMmps2 {return false}
    if lhs.rightWheelMmps2 != rhs.rightWheelMmps2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DriveWheelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DriveWheelsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DriveWheelsResponse, rhs: Anki_Vector_ExternalInterface_DriveWheelsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_MoveHeadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MoveHeadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "speed_rad_per_sec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.speedRadPerSec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.speedRadPerSec != 0 {
      try visitor.visitSingularFloatField(value: self.speedRadPerSec, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_MoveHeadRequest, rhs: Anki_Vector_ExternalInterface_MoveHeadRequest) -> Bool {
    if lhs.speedRadPerSec != rhs.speedRadPerSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_MoveHeadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MoveHeadResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_MoveHeadResponse, rhs: Anki_Vector_ExternalInterface_MoveHeadResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_MoveLiftRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MoveLiftRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "speed_rad_per_sec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.speedRadPerSec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.speedRadPerSec != 0 {
      try visitor.visitSingularFloatField(value: self.speedRadPerSec, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_MoveLiftRequest, rhs: Anki_Vector_ExternalInterface_MoveLiftRequest) -> Bool {
    if lhs.speedRadPerSec != rhs.speedRadPerSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_MoveLiftResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MoveLiftResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_MoveLiftResponse, rhs: Anki_Vector_ExternalInterface_MoveLiftResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_StopAllMotorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopAllMotorsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_StopAllMotorsRequest, rhs: Anki_Vector_ExternalInterface_StopAllMotorsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_StopAllMotorsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopAllMotorsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_StopAllMotorsResponse, rhs: Anki_Vector_ExternalInterface_StopAllMotorsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PlayAnimationTriggerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayAnimationTriggerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "animation_trigger"),
    2: .same(proto: "loops"),
    3: .standard(proto: "use_lift_safe"),
    4: .standard(proto: "ignore_body_track"),
    5: .standard(proto: "ignore_head_track"),
    6: .standard(proto: "ignore_lift_track"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._animationTrigger) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.loops) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.useLiftSafe) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.ignoreBodyTrack) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.ignoreHeadTrack) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.ignoreLiftTrack) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._animationTrigger {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.loops != 0 {
      try visitor.visitSingularUInt32Field(value: self.loops, fieldNumber: 2)
    }
    if self.useLiftSafe != false {
      try visitor.visitSingularBoolField(value: self.useLiftSafe, fieldNumber: 3)
    }
    if self.ignoreBodyTrack != false {
      try visitor.visitSingularBoolField(value: self.ignoreBodyTrack, fieldNumber: 4)
    }
    if self.ignoreHeadTrack != false {
      try visitor.visitSingularBoolField(value: self.ignoreHeadTrack, fieldNumber: 5)
    }
    if self.ignoreLiftTrack != false {
      try visitor.visitSingularBoolField(value: self.ignoreLiftTrack, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PlayAnimationTriggerRequest, rhs: Anki_Vector_ExternalInterface_PlayAnimationTriggerRequest) -> Bool {
    if lhs._animationTrigger != rhs._animationTrigger {return false}
    if lhs.loops != rhs.loops {return false}
    if lhs.useLiftSafe != rhs.useLiftSafe {return false}
    if lhs.ignoreBodyTrack != rhs.ignoreBodyTrack {return false}
    if lhs.ignoreHeadTrack != rhs.ignoreHeadTrack {return false}
    if lhs.ignoreLiftTrack != rhs.ignoreLiftTrack {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PlayAnimationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayAnimationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "animation"),
    2: .same(proto: "loops"),
    3: .standard(proto: "ignore_body_track"),
    4: .standard(proto: "ignore_head_track"),
    5: .standard(proto: "ignore_lift_track"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._animation) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.loops) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.ignoreBodyTrack) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.ignoreHeadTrack) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.ignoreLiftTrack) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._animation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.loops != 0 {
      try visitor.visitSingularUInt32Field(value: self.loops, fieldNumber: 2)
    }
    if self.ignoreBodyTrack != false {
      try visitor.visitSingularBoolField(value: self.ignoreBodyTrack, fieldNumber: 3)
    }
    if self.ignoreHeadTrack != false {
      try visitor.visitSingularBoolField(value: self.ignoreHeadTrack, fieldNumber: 4)
    }
    if self.ignoreLiftTrack != false {
      try visitor.visitSingularBoolField(value: self.ignoreLiftTrack, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PlayAnimationRequest, rhs: Anki_Vector_ExternalInterface_PlayAnimationRequest) -> Bool {
    if lhs._animation != rhs._animation {return false}
    if lhs.loops != rhs.loops {return false}
    if lhs.ignoreBodyTrack != rhs.ignoreBodyTrack {return false}
    if lhs.ignoreHeadTrack != rhs.ignoreHeadTrack {return false}
    if lhs.ignoreLiftTrack != rhs.ignoreLiftTrack {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PlayAnimationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayAnimationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
    3: .same(proto: "animation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._animation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.result != .behaviorInvalidState {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 2)
    }
    try { if let v = self._animation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PlayAnimationResponse, rhs: Anki_Vector_ExternalInterface_PlayAnimationResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.result != rhs.result {return false}
    if lhs._animation != rhs._animation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ListAnimationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAnimationsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ListAnimationsRequest, rhs: Anki_Vector_ExternalInterface_ListAnimationsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ListAnimationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAnimationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "animation_names"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.animationNames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.animationNames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.animationNames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ListAnimationsResponse, rhs: Anki_Vector_ExternalInterface_ListAnimationsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.animationNames != rhs.animationNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ListAnimationTriggersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAnimationTriggersRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ListAnimationTriggersRequest, rhs: Anki_Vector_ExternalInterface_ListAnimationTriggersRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ListAnimationTriggersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAnimationTriggersResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "animation_trigger_names"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.animationTriggerNames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.animationTriggerNames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.animationTriggerNames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ListAnimationTriggersResponse, rhs: Anki_Vector_ExternalInterface_ListAnimationTriggersResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.animationTriggerNames != rhs.animationTriggerNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DisplayFaceImageRGBRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisplayFaceImageRGBRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "face_data"),
    2: .standard(proto: "duration_ms"),
    3: .standard(proto: "interrupt_running"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.faceData) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.durationMs) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.interruptRunning) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.faceData.isEmpty {
      try visitor.visitSingularBytesField(value: self.faceData, fieldNumber: 1)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationMs, fieldNumber: 2)
    }
    if self.interruptRunning != false {
      try visitor.visitSingularBoolField(value: self.interruptRunning, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DisplayFaceImageRGBRequest, rhs: Anki_Vector_ExternalInterface_DisplayFaceImageRGBRequest) -> Bool {
    if lhs.faceData != rhs.faceData {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.interruptRunning != rhs.interruptRunning {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DisplayFaceImageRGBResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisplayFaceImageRGBResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DisplayFaceImageRGBResponse, rhs: Anki_Vector_ExternalInterface_DisplayFaceImageRGBResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_MeetVictorFaceScanStarted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MeetVictorFaceScanStarted"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_MeetVictorFaceScanStarted, rhs: Anki_Vector_ExternalInterface_MeetVictorFaceScanStarted) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_MeetVictorFaceScanComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MeetVictorFaceScanComplete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_MeetVictorFaceScanComplete, rhs: Anki_Vector_ExternalInterface_MeetVictorFaceScanComplete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Status"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "meet_victor_face_scan_started"),
    3: .standard(proto: "meet_victor_face_scan_complete"),
    4: .standard(proto: "face_enrollment_completed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Anki_Vector_ExternalInterface_MeetVictorFaceScanStarted?
        var hadOneofValue = false
        if let current = self.statusType {
          hadOneofValue = true
          if case .meetVictorFaceScanStarted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.statusType = .meetVictorFaceScanStarted(v)
        }
      }()
      case 3: try {
        var v: Anki_Vector_ExternalInterface_MeetVictorFaceScanComplete?
        var hadOneofValue = false
        if let current = self.statusType {
          hadOneofValue = true
          if case .meetVictorFaceScanComplete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.statusType = .meetVictorFaceScanComplete(v)
        }
      }()
      case 4: try {
        var v: Anki_Vector_ExternalInterface_FaceEnrollmentCompleted?
        var hadOneofValue = false
        if let current = self.statusType {
          hadOneofValue = true
          if case .faceEnrollmentCompleted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.statusType = .faceEnrollmentCompleted(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.statusType {
    case .meetVictorFaceScanStarted?: try {
      guard case .meetVictorFaceScanStarted(let v)? = self.statusType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .meetVictorFaceScanComplete?: try {
      guard case .meetVictorFaceScanComplete(let v)? = self.statusType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .faceEnrollmentCompleted?: try {
      guard case .faceEnrollmentCompleted(let v)? = self.statusType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_Status, rhs: Anki_Vector_ExternalInterface_Status) -> Bool {
    if lhs.statusType != rhs.statusType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_WakeWord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WakeWord"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wake_word_begin"),
    2: .standard(proto: "wake_word_end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Anki_Vector_ExternalInterface_WakeWordBegin?
        var hadOneofValue = false
        if let current = self.wakeWordType {
          hadOneofValue = true
          if case .wakeWordBegin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.wakeWordType = .wakeWordBegin(v)
        }
      }()
      case 2: try {
        var v: Anki_Vector_ExternalInterface_WakeWordEnd?
        var hadOneofValue = false
        if let current = self.wakeWordType {
          hadOneofValue = true
          if case .wakeWordEnd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.wakeWordType = .wakeWordEnd(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.wakeWordType {
    case .wakeWordBegin?: try {
      guard case .wakeWordBegin(let v)? = self.wakeWordType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .wakeWordEnd?: try {
      guard case .wakeWordEnd(let v)? = self.wakeWordType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_WakeWord, rhs: Anki_Vector_ExternalInterface_WakeWord) -> Bool {
    if lhs.wakeWordType != rhs.wakeWordType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_TimeStampedStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeStampedStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "timestamp_utc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.timestampUtc) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.timestampUtc != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampUtc, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_TimeStampedStatus, rhs: Anki_Vector_ExternalInterface_TimeStampedStatus) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.timestampUtc != rhs.timestampUtc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PoseStruct: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PoseStruct"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
    4: .same(proto: "q0"),
    5: .same(proto: "q1"),
    6: .same(proto: "q2"),
    7: .same(proto: "q3"),
    8: .standard(proto: "origin_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.z) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.q0) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.q1) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.q2) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.q3) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.originID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 3)
    }
    if self.q0 != 0 {
      try visitor.visitSingularFloatField(value: self.q0, fieldNumber: 4)
    }
    if self.q1 != 0 {
      try visitor.visitSingularFloatField(value: self.q1, fieldNumber: 5)
    }
    if self.q2 != 0 {
      try visitor.visitSingularFloatField(value: self.q2, fieldNumber: 6)
    }
    if self.q3 != 0 {
      try visitor.visitSingularFloatField(value: self.q3, fieldNumber: 7)
    }
    if self.originID != 0 {
      try visitor.visitSingularUInt32Field(value: self.originID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PoseStruct, rhs: Anki_Vector_ExternalInterface_PoseStruct) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.q0 != rhs.q0 {return false}
    if lhs.q1 != rhs.q1 {return false}
    if lhs.q2 != rhs.q2 {return false}
    if lhs.q3 != rhs.q3 {return false}
    if lhs.originID != rhs.originID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_AccelData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccelData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.z) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_AccelData, rhs: Anki_Vector_ExternalInterface_AccelData) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_GyroData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GyroData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.z) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_GyroData, rhs: Anki_Vector_ExternalInterface_GyroData) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ProxData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProxData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distance_mm"),
    2: .standard(proto: "signal_quality"),
    3: .same(proto: "unobstructed"),
    4: .standard(proto: "found_object"),
    5: .standard(proto: "is_lift_in_fov"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.distanceMm) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.signalQuality) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.unobstructed) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.foundObject) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isLiftInFov) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.distanceMm != 0 {
      try visitor.visitSingularUInt32Field(value: self.distanceMm, fieldNumber: 1)
    }
    if self.signalQuality != 0 {
      try visitor.visitSingularFloatField(value: self.signalQuality, fieldNumber: 2)
    }
    if self.unobstructed != false {
      try visitor.visitSingularBoolField(value: self.unobstructed, fieldNumber: 3)
    }
    if self.foundObject != false {
      try visitor.visitSingularBoolField(value: self.foundObject, fieldNumber: 4)
    }
    if self.isLiftInFov != false {
      try visitor.visitSingularBoolField(value: self.isLiftInFov, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ProxData, rhs: Anki_Vector_ExternalInterface_ProxData) -> Bool {
    if lhs.distanceMm != rhs.distanceMm {return false}
    if lhs.signalQuality != rhs.signalQuality {return false}
    if lhs.unobstructed != rhs.unobstructed {return false}
    if lhs.foundObject != rhs.foundObject {return false}
    if lhs.isLiftInFov != rhs.isLiftInFov {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_TouchData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TouchData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_touch_value"),
    2: .standard(proto: "is_being_touched"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.rawTouchValue) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isBeingTouched) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rawTouchValue != 0 {
      try visitor.visitSingularUInt32Field(value: self.rawTouchValue, fieldNumber: 1)
    }
    if self.isBeingTouched != false {
      try visitor.visitSingularBoolField(value: self.isBeingTouched, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_TouchData, rhs: Anki_Vector_ExternalInterface_TouchData) -> Bool {
    if lhs.rawTouchValue != rhs.rawTouchValue {return false}
    if lhs.isBeingTouched != rhs.isBeingTouched {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_RobotState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pose"),
    2: .standard(proto: "pose_angle_rad"),
    3: .standard(proto: "pose_pitch_rad"),
    4: .standard(proto: "left_wheel_speed_mmps"),
    5: .standard(proto: "right_wheel_speed_mmps"),
    6: .standard(proto: "head_angle_rad"),
    7: .standard(proto: "lift_height_mm"),
    8: .same(proto: "accel"),
    9: .same(proto: "gyro"),
    10: .standard(proto: "carrying_object_id"),
    11: .standard(proto: "carrying_object_on_top_id"),
    12: .standard(proto: "head_tracking_object_id"),
    13: .standard(proto: "localized_to_object_id"),
    14: .standard(proto: "last_image_time_stamp"),
    15: .same(proto: "status"),
    16: .standard(proto: "prox_data"),
    17: .standard(proto: "touch_data"),
  ]

  fileprivate class _StorageClass {
    var _pose: Anki_Vector_ExternalInterface_PoseStruct? = nil
    var _poseAngleRad: Float = 0
    var _posePitchRad: Float = 0
    var _leftWheelSpeedMmps: Float = 0
    var _rightWheelSpeedMmps: Float = 0
    var _headAngleRad: Float = 0
    var _liftHeightMm: Float = 0
    var _accel: Anki_Vector_ExternalInterface_AccelData? = nil
    var _gyro: Anki_Vector_ExternalInterface_GyroData? = nil
    var _carryingObjectID: Int32 = 0
    var _carryingObjectOnTopID: Int32 = 0
    var _headTrackingObjectID: Int32 = 0
    var _localizedToObjectID: Int32 = 0
    var _lastImageTimeStamp: UInt32 = 0
    var _status: UInt32 = 0
    var _proxData: Anki_Vector_ExternalInterface_ProxData? = nil
    var _touchData: Anki_Vector_ExternalInterface_TouchData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pose = source._pose
      _poseAngleRad = source._poseAngleRad
      _posePitchRad = source._posePitchRad
      _leftWheelSpeedMmps = source._leftWheelSpeedMmps
      _rightWheelSpeedMmps = source._rightWheelSpeedMmps
      _headAngleRad = source._headAngleRad
      _liftHeightMm = source._liftHeightMm
      _accel = source._accel
      _gyro = source._gyro
      _carryingObjectID = source._carryingObjectID
      _carryingObjectOnTopID = source._carryingObjectOnTopID
      _headTrackingObjectID = source._headTrackingObjectID
      _localizedToObjectID = source._localizedToObjectID
      _lastImageTimeStamp = source._lastImageTimeStamp
      _status = source._status
      _proxData = source._proxData
      _touchData = source._touchData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._pose) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._poseAngleRad) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._posePitchRad) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._leftWheelSpeedMmps) }()
        case 5: try { try decoder.decodeSingularFloatField(value: &_storage._rightWheelSpeedMmps) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._headAngleRad) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._liftHeightMm) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._accel) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._gyro) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._carryingObjectID) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._carryingObjectOnTopID) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._headTrackingObjectID) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._localizedToObjectID) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._lastImageTimeStamp) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._status) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._proxData) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._touchData) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._pose {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._poseAngleRad != 0 {
        try visitor.visitSingularFloatField(value: _storage._poseAngleRad, fieldNumber: 2)
      }
      if _storage._posePitchRad != 0 {
        try visitor.visitSingularFloatField(value: _storage._posePitchRad, fieldNumber: 3)
      }
      if _storage._leftWheelSpeedMmps != 0 {
        try visitor.visitSingularFloatField(value: _storage._leftWheelSpeedMmps, fieldNumber: 4)
      }
      if _storage._rightWheelSpeedMmps != 0 {
        try visitor.visitSingularFloatField(value: _storage._rightWheelSpeedMmps, fieldNumber: 5)
      }
      if _storage._headAngleRad != 0 {
        try visitor.visitSingularFloatField(value: _storage._headAngleRad, fieldNumber: 6)
      }
      if _storage._liftHeightMm != 0 {
        try visitor.visitSingularFloatField(value: _storage._liftHeightMm, fieldNumber: 7)
      }
      try { if let v = _storage._accel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._gyro {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._carryingObjectID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._carryingObjectID, fieldNumber: 10)
      }
      if _storage._carryingObjectOnTopID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._carryingObjectOnTopID, fieldNumber: 11)
      }
      if _storage._headTrackingObjectID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._headTrackingObjectID, fieldNumber: 12)
      }
      if _storage._localizedToObjectID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._localizedToObjectID, fieldNumber: 13)
      }
      if _storage._lastImageTimeStamp != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lastImageTimeStamp, fieldNumber: 14)
      }
      if _storage._status != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._status, fieldNumber: 15)
      }
      try { if let v = _storage._proxData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._touchData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_RobotState, rhs: Anki_Vector_ExternalInterface_RobotState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pose != rhs_storage._pose {return false}
        if _storage._poseAngleRad != rhs_storage._poseAngleRad {return false}
        if _storage._posePitchRad != rhs_storage._posePitchRad {return false}
        if _storage._leftWheelSpeedMmps != rhs_storage._leftWheelSpeedMmps {return false}
        if _storage._rightWheelSpeedMmps != rhs_storage._rightWheelSpeedMmps {return false}
        if _storage._headAngleRad != rhs_storage._headAngleRad {return false}
        if _storage._liftHeightMm != rhs_storage._liftHeightMm {return false}
        if _storage._accel != rhs_storage._accel {return false}
        if _storage._gyro != rhs_storage._gyro {return false}
        if _storage._carryingObjectID != rhs_storage._carryingObjectID {return false}
        if _storage._carryingObjectOnTopID != rhs_storage._carryingObjectOnTopID {return false}
        if _storage._headTrackingObjectID != rhs_storage._headTrackingObjectID {return false}
        if _storage._localizedToObjectID != rhs_storage._localizedToObjectID {return false}
        if _storage._lastImageTimeStamp != rhs_storage._lastImageTimeStamp {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._proxData != rhs_storage._proxData {return false}
        if _storage._touchData != rhs_storage._touchData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CladPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CladPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CladPoint, rhs: Anki_Vector_ExternalInterface_CladPoint) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CladRect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CladRect"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "x_top_left"),
    2: .standard(proto: "y_top_left"),
    3: .same(proto: "width"),
    4: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.xTopLeft) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.yTopLeft) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.width) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.xTopLeft != 0 {
      try visitor.visitSingularFloatField(value: self.xTopLeft, fieldNumber: 1)
    }
    if self.yTopLeft != 0 {
      try visitor.visitSingularFloatField(value: self.yTopLeft, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularFloatField(value: self.width, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularFloatField(value: self.height, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CladRect, rhs: Anki_Vector_ExternalInterface_CladRect) -> Bool {
    if lhs.xTopLeft != rhs.xTopLeft {return false}
    if lhs.yTopLeft != rhs.yTopLeft {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_RobotObservedFace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotObservedFace"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "face_id"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "pose"),
    4: .standard(proto: "img_rect"),
    5: .same(proto: "name"),
    6: .same(proto: "expression"),
    7: .standard(proto: "expression_values"),
    8: .standard(proto: "left_eye"),
    9: .standard(proto: "right_eye"),
    10: .same(proto: "nose"),
    11: .same(proto: "mouth"),
  ]

  fileprivate class _StorageClass {
    var _faceID: Int32 = 0
    var _timestamp: UInt32 = 0
    var _pose: Anki_Vector_ExternalInterface_PoseStruct? = nil
    var _imgRect: Anki_Vector_ExternalInterface_CladRect? = nil
    var _name: String = String()
    var _expression: Anki_Vector_ExternalInterface_FacialExpression = .expressionUnknown
    var _expressionValues: [UInt32] = []
    var _leftEye: [Anki_Vector_ExternalInterface_CladPoint] = []
    var _rightEye: [Anki_Vector_ExternalInterface_CladPoint] = []
    var _nose: [Anki_Vector_ExternalInterface_CladPoint] = []
    var _mouth: [Anki_Vector_ExternalInterface_CladPoint] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _faceID = source._faceID
      _timestamp = source._timestamp
      _pose = source._pose
      _imgRect = source._imgRect
      _name = source._name
      _expression = source._expression
      _expressionValues = source._expressionValues
      _leftEye = source._leftEye
      _rightEye = source._rightEye
      _nose = source._nose
      _mouth = source._mouth
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._faceID) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._timestamp) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._pose) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._imgRect) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._expression) }()
        case 7: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._expressionValues) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._leftEye) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._rightEye) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._nose) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._mouth) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._faceID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._faceID, fieldNumber: 1)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._timestamp, fieldNumber: 2)
      }
      try { if let v = _storage._pose {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._imgRect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 5)
      }
      if _storage._expression != .expressionUnknown {
        try visitor.visitSingularEnumField(value: _storage._expression, fieldNumber: 6)
      }
      if !_storage._expressionValues.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._expressionValues, fieldNumber: 7)
      }
      if !_storage._leftEye.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._leftEye, fieldNumber: 8)
      }
      if !_storage._rightEye.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rightEye, fieldNumber: 9)
      }
      if !_storage._nose.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._nose, fieldNumber: 10)
      }
      if !_storage._mouth.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mouth, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_RobotObservedFace, rhs: Anki_Vector_ExternalInterface_RobotObservedFace) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._faceID != rhs_storage._faceID {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._pose != rhs_storage._pose {return false}
        if _storage._imgRect != rhs_storage._imgRect {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._expression != rhs_storage._expression {return false}
        if _storage._expressionValues != rhs_storage._expressionValues {return false}
        if _storage._leftEye != rhs_storage._leftEye {return false}
        if _storage._rightEye != rhs_storage._rightEye {return false}
        if _storage._nose != rhs_storage._nose {return false}
        if _storage._mouth != rhs_storage._mouth {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_RobotChangedObservedFaceID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotChangedObservedFaceID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "old_id"),
    2: .standard(proto: "new_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.oldID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.newID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.oldID != 0 {
      try visitor.visitSingularInt32Field(value: self.oldID, fieldNumber: 1)
    }
    if self.newID != 0 {
      try visitor.visitSingularInt32Field(value: self.newID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_RobotChangedObservedFaceID, rhs: Anki_Vector_ExternalInterface_RobotChangedObservedFaceID) -> Bool {
    if lhs.oldID != rhs.oldID {return false}
    if lhs.newID != rhs.newID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_FaceEnrollmentCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FaceEnrollmentCompleted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "face_id"),
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.faceID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.faceID != 0 {
      try visitor.visitSingularInt32Field(value: self.faceID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_FaceEnrollmentCompleted, rhs: Anki_Vector_ExternalInterface_FaceEnrollmentCompleted) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.faceID != rhs.faceID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CancelFaceEnrollmentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelFaceEnrollmentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CancelFaceEnrollmentRequest, rhs: Anki_Vector_ExternalInterface_CancelFaceEnrollmentRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CancelFaceEnrollmentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelFaceEnrollmentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CancelFaceEnrollmentResponse, rhs: Anki_Vector_ExternalInterface_CancelFaceEnrollmentResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_RequestEnrolledNamesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestEnrolledNamesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_RequestEnrolledNamesRequest, rhs: Anki_Vector_ExternalInterface_RequestEnrolledNamesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_LoadedKnownFace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadedKnownFace"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "seconds_since_first_enrolled"),
    2: .standard(proto: "seconds_since_last_updated"),
    3: .standard(proto: "seconds_since_last_seen"),
    4: .standard(proto: "last_seen_seconds_since_epoch"),
    5: .standard(proto: "face_id"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.secondsSinceFirstEnrolled) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.secondsSinceLastUpdated) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.secondsSinceLastSeen) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lastSeenSecondsSinceEpoch) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.faceID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.secondsSinceFirstEnrolled != 0 {
      try visitor.visitSingularInt64Field(value: self.secondsSinceFirstEnrolled, fieldNumber: 1)
    }
    if self.secondsSinceLastUpdated != 0 {
      try visitor.visitSingularInt64Field(value: self.secondsSinceLastUpdated, fieldNumber: 2)
    }
    if self.secondsSinceLastSeen != 0 {
      try visitor.visitSingularInt64Field(value: self.secondsSinceLastSeen, fieldNumber: 3)
    }
    if self.lastSeenSecondsSinceEpoch != 0 {
      try visitor.visitSingularInt64Field(value: self.lastSeenSecondsSinceEpoch, fieldNumber: 4)
    }
    if self.faceID != 0 {
      try visitor.visitSingularInt32Field(value: self.faceID, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_LoadedKnownFace, rhs: Anki_Vector_ExternalInterface_LoadedKnownFace) -> Bool {
    if lhs.secondsSinceFirstEnrolled != rhs.secondsSinceFirstEnrolled {return false}
    if lhs.secondsSinceLastUpdated != rhs.secondsSinceLastUpdated {return false}
    if lhs.secondsSinceLastSeen != rhs.secondsSinceLastSeen {return false}
    if lhs.lastSeenSecondsSinceEpoch != rhs.lastSeenSecondsSinceEpoch {return false}
    if lhs.faceID != rhs.faceID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_RobotRenamedEnrolledFace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotRenamedEnrolledFace"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "face_id"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.faceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.faceID != 0 {
      try visitor.visitSingularInt32Field(value: self.faceID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_RobotRenamedEnrolledFace, rhs: Anki_Vector_ExternalInterface_RobotRenamedEnrolledFace) -> Bool {
    if lhs.faceID != rhs.faceID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_RequestEnrolledNamesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestEnrolledNamesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "faces"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.faces) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.faces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.faces, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_RequestEnrolledNamesResponse, rhs: Anki_Vector_ExternalInterface_RequestEnrolledNamesResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.faces != rhs.faces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_UpdateEnrolledFaceByIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateEnrolledFaceByIDRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "face_id"),
    2: .standard(proto: "old_name"),
    3: .standard(proto: "new_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.faceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.oldName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.newName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.faceID != 0 {
      try visitor.visitSingularInt32Field(value: self.faceID, fieldNumber: 1)
    }
    if !self.oldName.isEmpty {
      try visitor.visitSingularStringField(value: self.oldName, fieldNumber: 2)
    }
    if !self.newName.isEmpty {
      try visitor.visitSingularStringField(value: self.newName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_UpdateEnrolledFaceByIDRequest, rhs: Anki_Vector_ExternalInterface_UpdateEnrolledFaceByIDRequest) -> Bool {
    if lhs.faceID != rhs.faceID {return false}
    if lhs.oldName != rhs.oldName {return false}
    if lhs.newName != rhs.newName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_UpdateEnrolledFaceByIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateEnrolledFaceByIDResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_UpdateEnrolledFaceByIDResponse, rhs: Anki_Vector_ExternalInterface_UpdateEnrolledFaceByIDResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_EraseEnrolledFaceByIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EraseEnrolledFaceByIDRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "face_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.faceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.faceID != 0 {
      try visitor.visitSingularInt32Field(value: self.faceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_EraseEnrolledFaceByIDRequest, rhs: Anki_Vector_ExternalInterface_EraseEnrolledFaceByIDRequest) -> Bool {
    if lhs.faceID != rhs.faceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_EraseEnrolledFaceByIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EraseEnrolledFaceByIDResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_EraseEnrolledFaceByIDResponse, rhs: Anki_Vector_ExternalInterface_EraseEnrolledFaceByIDResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_EraseAllEnrolledFacesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EraseAllEnrolledFacesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_EraseAllEnrolledFacesRequest, rhs: Anki_Vector_ExternalInterface_EraseAllEnrolledFacesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_EraseAllEnrolledFacesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EraseAllEnrolledFacesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_EraseAllEnrolledFacesResponse, rhs: Anki_Vector_ExternalInterface_EraseAllEnrolledFacesResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SetFaceToEnrollRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetFaceToEnrollRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "observed_id"),
    3: .standard(proto: "save_id"),
    4: .standard(proto: "save_to_robot"),
    5: .standard(proto: "say_name"),
    6: .standard(proto: "use_music"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.observedID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.saveID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.saveToRobot) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.sayName) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.useMusic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.observedID != 0 {
      try visitor.visitSingularInt32Field(value: self.observedID, fieldNumber: 2)
    }
    if self.saveID != 0 {
      try visitor.visitSingularInt32Field(value: self.saveID, fieldNumber: 3)
    }
    if self.saveToRobot != false {
      try visitor.visitSingularBoolField(value: self.saveToRobot, fieldNumber: 4)
    }
    if self.sayName != false {
      try visitor.visitSingularBoolField(value: self.sayName, fieldNumber: 5)
    }
    if self.useMusic != false {
      try visitor.visitSingularBoolField(value: self.useMusic, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SetFaceToEnrollRequest, rhs: Anki_Vector_ExternalInterface_SetFaceToEnrollRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.observedID != rhs.observedID {return false}
    if lhs.saveID != rhs.saveID {return false}
    if lhs.saveToRobot != rhs.saveToRobot {return false}
    if lhs.sayName != rhs.sayName {return false}
    if lhs.useMusic != rhs.useMusic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SetFaceToEnrollResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetFaceToEnrollResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SetFaceToEnrollResponse, rhs: Anki_Vector_ExternalInterface_SetFaceToEnrollResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DriveOffChargerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DriveOffChargerRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DriveOffChargerRequest, rhs: Anki_Vector_ExternalInterface_DriveOffChargerRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DriveOffChargerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DriveOffChargerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.result != .behaviorInvalidState {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DriveOffChargerResponse, rhs: Anki_Vector_ExternalInterface_DriveOffChargerResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DriveOnChargerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DriveOnChargerRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DriveOnChargerRequest, rhs: Anki_Vector_ExternalInterface_DriveOnChargerRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DriveOnChargerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DriveOnChargerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.result != .behaviorInvalidState {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DriveOnChargerResponse, rhs: Anki_Vector_ExternalInterface_DriveOnChargerResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_FindFacesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindFacesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_FindFacesRequest, rhs: Anki_Vector_ExternalInterface_FindFacesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_FindFacesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindFacesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.result != .behaviorInvalidState {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_FindFacesResponse, rhs: Anki_Vector_ExternalInterface_FindFacesResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_LookAroundInPlaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LookAroundInPlaceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_LookAroundInPlaceRequest, rhs: Anki_Vector_ExternalInterface_LookAroundInPlaceRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_LookAroundInPlaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LookAroundInPlaceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.result != .behaviorInvalidState {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_LookAroundInPlaceResponse, rhs: Anki_Vector_ExternalInterface_LookAroundInPlaceResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_RollBlockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollBlockRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_RollBlockRequest, rhs: Anki_Vector_ExternalInterface_RollBlockRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_RollBlockResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollBlockResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.result != .behaviorInvalidState {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_RollBlockResponse, rhs: Anki_Vector_ExternalInterface_RollBlockResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_WakeWordBegin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WakeWordBegin"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_WakeWordBegin, rhs: Anki_Vector_ExternalInterface_WakeWordBegin) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_WakeWordEnd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WakeWordEnd"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "intent_heard"),
    2: .standard(proto: "intent_json"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.intentHeard) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.intentJson) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.intentHeard != false {
      try visitor.visitSingularBoolField(value: self.intentHeard, fieldNumber: 1)
    }
    if !self.intentJson.isEmpty {
      try visitor.visitSingularStringField(value: self.intentJson, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_WakeWordEnd, rhs: Anki_Vector_ExternalInterface_WakeWordEnd) -> Bool {
    if lhs.intentHeard != rhs.intentHeard {return false}
    if lhs.intentJson != rhs.intentJson {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_UserIntent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserIntent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "intent_id"),
    2: .standard(proto: "json_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.intentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.jsonData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.intentID != 0 {
      try visitor.visitSingularUInt32Field(value: self.intentID, fieldNumber: 1)
    }
    if !self.jsonData.isEmpty {
      try visitor.visitSingularStringField(value: self.jsonData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_UserIntent, rhs: Anki_Vector_ExternalInterface_UserIntent) -> Bool {
    if lhs.intentID != rhs.intentID {return false}
    if lhs.jsonData != rhs.jsonData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PhotoInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PhotoInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "photo_id"),
    2: .standard(proto: "timestamp_utc"),
    3: .standard(proto: "photo_copied_to_app"),
    4: .standard(proto: "thumb_copied_to_app"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.photoID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.timestampUtc) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.photoCopiedToApp) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.thumbCopiedToApp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.photoID != 0 {
      try visitor.visitSingularUInt32Field(value: self.photoID, fieldNumber: 1)
    }
    if self.timestampUtc != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampUtc, fieldNumber: 2)
    }
    if self.photoCopiedToApp != false {
      try visitor.visitSingularBoolField(value: self.photoCopiedToApp, fieldNumber: 3)
    }
    if self.thumbCopiedToApp != false {
      try visitor.visitSingularBoolField(value: self.thumbCopiedToApp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PhotoInfo, rhs: Anki_Vector_ExternalInterface_PhotoInfo) -> Bool {
    if lhs.photoID != rhs.photoID {return false}
    if lhs.timestampUtc != rhs.timestampUtc {return false}
    if lhs.photoCopiedToApp != rhs.photoCopiedToApp {return false}
    if lhs.thumbCopiedToApp != rhs.thumbCopiedToApp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PhotosInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PhotosInfoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PhotosInfoRequest, rhs: Anki_Vector_ExternalInterface_PhotosInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PhotosInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PhotosInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "photo_infos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.photoInfos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.photoInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.photoInfos, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PhotosInfoResponse, rhs: Anki_Vector_ExternalInterface_PhotosInfoResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.photoInfos != rhs.photoInfos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PhotoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PhotoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "photo_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.photoID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.photoID != 0 {
      try visitor.visitSingularUInt32Field(value: self.photoID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PhotoRequest, rhs: Anki_Vector_ExternalInterface_PhotoRequest) -> Bool {
    if lhs.photoID != rhs.photoID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PhotoPathMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PhotoPathMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "full_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fullPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.fullPath.isEmpty {
      try visitor.visitSingularStringField(value: self.fullPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PhotoPathMessage, rhs: Anki_Vector_ExternalInterface_PhotoPathMessage) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.fullPath != rhs.fullPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PhotoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PhotoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "success"),
    3: .same(proto: "image"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.image) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if !self.image.isEmpty {
      try visitor.visitSingularBytesField(value: self.image, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PhotoResponse, rhs: Anki_Vector_ExternalInterface_PhotoResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.success != rhs.success {return false}
    if lhs.image != rhs.image {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ThumbnailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThumbnailRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "photo_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.photoID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.photoID != 0 {
      try visitor.visitSingularUInt32Field(value: self.photoID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ThumbnailRequest, rhs: Anki_Vector_ExternalInterface_ThumbnailRequest) -> Bool {
    if lhs.photoID != rhs.photoID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ThumbnailPathMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThumbnailPathMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "full_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fullPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.fullPath.isEmpty {
      try visitor.visitSingularStringField(value: self.fullPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ThumbnailPathMessage, rhs: Anki_Vector_ExternalInterface_ThumbnailPathMessage) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.fullPath != rhs.fullPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ThumbnailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThumbnailResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "success"),
    3: .same(proto: "image"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.image) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if !self.image.isEmpty {
      try visitor.visitSingularBytesField(value: self.image, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ThumbnailResponse, rhs: Anki_Vector_ExternalInterface_ThumbnailResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.success != rhs.success {return false}
    if lhs.image != rhs.image {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DeletePhotoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePhotoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "photo_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.photoID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.photoID != 0 {
      try visitor.visitSingularUInt32Field(value: self.photoID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DeletePhotoRequest, rhs: Anki_Vector_ExternalInterface_DeletePhotoRequest) -> Bool {
    if lhs.photoID != rhs.photoID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DeletePhotoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePhotoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DeletePhotoResponse, rhs: Anki_Vector_ExternalInterface_DeletePhotoResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PhotoTaken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PhotoTaken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "photo_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.photoID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.photoID != 0 {
      try visitor.visitSingularUInt32Field(value: self.photoID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PhotoTaken, rhs: Anki_Vector_ExternalInterface_PhotoTaken) -> Bool {
    if lhs.photoID != rhs.photoID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PathMotionProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PathMotionProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "speed_mmps"),
    2: .standard(proto: "accel_mmps2"),
    3: .standard(proto: "decel_mmps2"),
    4: .standard(proto: "point_turn_speed_rad_per_sec"),
    5: .standard(proto: "point_turn_accel_rad_per_sec2"),
    6: .standard(proto: "point_turn_decel_rad_per_sec2"),
    7: .standard(proto: "dock_speed_mmps"),
    8: .standard(proto: "dock_accel_mmps2"),
    9: .standard(proto: "dock_decel_mmps2"),
    10: .standard(proto: "reverse_speed_mmps"),
    11: .standard(proto: "is_custom"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.speedMmps) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.accelMmps2) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.decelMmps2) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.pointTurnSpeedRadPerSec) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.pointTurnAccelRadPerSec2) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.pointTurnDecelRadPerSec2) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.dockSpeedMmps) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.dockAccelMmps2) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.dockDecelMmps2) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.reverseSpeedMmps) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.isCustom) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.speedMmps != 0 {
      try visitor.visitSingularFloatField(value: self.speedMmps, fieldNumber: 1)
    }
    if self.accelMmps2 != 0 {
      try visitor.visitSingularFloatField(value: self.accelMmps2, fieldNumber: 2)
    }
    if self.decelMmps2 != 0 {
      try visitor.visitSingularFloatField(value: self.decelMmps2, fieldNumber: 3)
    }
    if self.pointTurnSpeedRadPerSec != 0 {
      try visitor.visitSingularFloatField(value: self.pointTurnSpeedRadPerSec, fieldNumber: 4)
    }
    if self.pointTurnAccelRadPerSec2 != 0 {
      try visitor.visitSingularFloatField(value: self.pointTurnAccelRadPerSec2, fieldNumber: 5)
    }
    if self.pointTurnDecelRadPerSec2 != 0 {
      try visitor.visitSingularFloatField(value: self.pointTurnDecelRadPerSec2, fieldNumber: 6)
    }
    if self.dockSpeedMmps != 0 {
      try visitor.visitSingularFloatField(value: self.dockSpeedMmps, fieldNumber: 7)
    }
    if self.dockAccelMmps2 != 0 {
      try visitor.visitSingularFloatField(value: self.dockAccelMmps2, fieldNumber: 8)
    }
    if self.dockDecelMmps2 != 0 {
      try visitor.visitSingularFloatField(value: self.dockDecelMmps2, fieldNumber: 9)
    }
    if self.reverseSpeedMmps != 0 {
      try visitor.visitSingularFloatField(value: self.reverseSpeedMmps, fieldNumber: 10)
    }
    if self.isCustom != false {
      try visitor.visitSingularBoolField(value: self.isCustom, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PathMotionProfile, rhs: Anki_Vector_ExternalInterface_PathMotionProfile) -> Bool {
    if lhs.speedMmps != rhs.speedMmps {return false}
    if lhs.accelMmps2 != rhs.accelMmps2 {return false}
    if lhs.decelMmps2 != rhs.decelMmps2 {return false}
    if lhs.pointTurnSpeedRadPerSec != rhs.pointTurnSpeedRadPerSec {return false}
    if lhs.pointTurnAccelRadPerSec2 != rhs.pointTurnAccelRadPerSec2 {return false}
    if lhs.pointTurnDecelRadPerSec2 != rhs.pointTurnDecelRadPerSec2 {return false}
    if lhs.dockSpeedMmps != rhs.dockSpeedMmps {return false}
    if lhs.dockAccelMmps2 != rhs.dockAccelMmps2 {return false}
    if lhs.dockDecelMmps2 != rhs.dockDecelMmps2 {return false}
    if lhs.reverseSpeedMmps != rhs.reverseSpeedMmps {return false}
    if lhs.isCustom != rhs.isCustom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ActionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .actionResultSuccess {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ActionResult, rhs: Anki_Vector_ExternalInterface_ActionResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ActionResult.ActionResultCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTION_RESULT_SUCCESS"),
    16777216: .same(proto: "ACTION_RESULT_RUNNING"),
    33554432: .same(proto: "ACTION_RESULT_CANCELLED_WHILE_RUNNING"),
    33554433: .same(proto: "NOT_STARTED"),
    50331648: .same(proto: "ABORT"),
    50331649: .same(proto: "ANIM_ABORTED"),
    50331650: .same(proto: "BAD_MARKER"),
    50331651: .same(proto: "BAD_MESSAGE_TAG"),
    50331652: .same(proto: "BAD_OBJECT"),
    50331653: .same(proto: "BAD_POSE"),
    50331654: .same(proto: "BAD_TAG"),
    50331655: .same(proto: "CHARGER_UNPLUGGED_ABORT"),
    50331656: .same(proto: "CLIFF_ALIGN_FAILED_TIMEOUT"),
    50331657: .same(proto: "CLIFF_ALIGN_FAILED_NO_TURNING"),
    50331658: .same(proto: "CLIFF_ALIGN_FAILED_OVER_TURNING"),
    50331659: .same(proto: "CLIFF_ALIGN_FAILED_NO_WHITE"),
    50331660: .same(proto: "CLIFF_ALIGN_FAILED_STOPPED"),
    50331661: .same(proto: "FAILED_SETTING_CALIBRATION"),
    50331662: .same(proto: "FOLLOWING_PATH_BUT_NOT_TRAVERSING"),
    50331663: .same(proto: "INTERRUPTED"),
    50331664: .same(proto: "INVALID_OFF_TREADS_STATE"),
    50331665: .same(proto: "MISMATCHED_UP_AXIS"),
    50331666: .same(proto: "NO_ANIM_NAME"),
    50331667: .same(proto: "NO_DISTANCE_SET"),
    50331668: .same(proto: "NO_FACE"),
    50331669: .same(proto: "NO_GOAL_SET"),
    50331670: .same(proto: "NO_PREACTION_POSES"),
    50331671: .same(proto: "NOT_CARRYING_OBJECT_ABORT"),
    50331672: .same(proto: "NOT_ON_CHARGER_ABORT"),
    50331673: .same(proto: "NULL_SUBACTION"),
    50331674: .same(proto: "PATH_PLANNING_FAILED_ABORT"),
    50331675: .same(proto: "PICKUP_OBJECT_UNEXPECTEDLY_MOVING"),
    50331676: .same(proto: "SEND_MESSAGE_TO_ROBOT_FAILED"),
    50331677: .same(proto: "STILL_CARRYING_OBJECT"),
    50331678: .same(proto: "TIMEOUT"),
    50331679: .same(proto: "TRACKS_LOCKED"),
    50331680: .same(proto: "UNEXPECTED_DOCK_ACTION"),
    50331681: .same(proto: "UNKNOWN_TOOL_CODE"),
    50331682: .same(proto: "UPDATE_DERIVED_FAILED"),
    50331683: .same(proto: "VISUAL_OBSERVATION_FAILED"),
    50331684: .same(proto: "SHOULDNT_DRIVE_ON_CHARGER"),
    67108864: .same(proto: "RETRY"),
    67108865: .same(proto: "DID_NOT_REACH_PREACTION_POSE"),
    67108866: .same(proto: "FAILED_TRAVERSING_PATH"),
    67108867: .same(proto: "LAST_PICK_AND_PLACE_FAILED"),
    67108868: .same(proto: "MOTOR_STOPPED_MAKING_PROGRESS"),
    67108869: .same(proto: "NOT_CARRYING_OBJECT_RETRY"),
    67108870: .same(proto: "NOT_ON_CHARGER_RETRY"),
    67108871: .same(proto: "PATH_PLANNING_FAILED_RETRY"),
    67108872: .same(proto: "PLACEMENT_GOAL_NOT_FREE"),
    67108873: .same(proto: "PICKUP_OBJECT_UNEXPECTEDLY_NOT_MOVING"),
    67108874: .same(proto: "STILL_ON_CHARGER"),
    67108875: .same(proto: "UNEXPECTED_PITCH_ANGLE"),
  ]
}

extension Anki_Vector_ExternalInterface_CancelActionByIdTagRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelActionByIdTagRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.idTag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.idTag != 0 {
      try visitor.visitSingularUInt32Field(value: self.idTag, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CancelActionByIdTagRequest, rhs: Anki_Vector_ExternalInterface_CancelActionByIdTagRequest) -> Bool {
    if lhs.idTag != rhs.idTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CancelActionByIdTagResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelActionByIdTagResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CancelActionByIdTagResponse, rhs: Anki_Vector_ExternalInterface_CancelActionByIdTagResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_GoToPoseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GoToPoseRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "x_mm"),
    2: .standard(proto: "y_mm"),
    3: .same(proto: "rad"),
    4: .standard(proto: "motion_prof"),
    5: .standard(proto: "id_tag"),
    6: .standard(proto: "num_retries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.xMm) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.yMm) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.rad) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._motionProf) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.idTag) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.numRetries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.xMm != 0 {
      try visitor.visitSingularFloatField(value: self.xMm, fieldNumber: 1)
    }
    if self.yMm != 0 {
      try visitor.visitSingularFloatField(value: self.yMm, fieldNumber: 2)
    }
    if self.rad != 0 {
      try visitor.visitSingularFloatField(value: self.rad, fieldNumber: 3)
    }
    try { if let v = self._motionProf {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.idTag != 0 {
      try visitor.visitSingularInt32Field(value: self.idTag, fieldNumber: 5)
    }
    if self.numRetries != 0 {
      try visitor.visitSingularInt32Field(value: self.numRetries, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_GoToPoseRequest, rhs: Anki_Vector_ExternalInterface_GoToPoseRequest) -> Bool {
    if lhs.xMm != rhs.xMm {return false}
    if lhs.yMm != rhs.yMm {return false}
    if lhs.rad != rhs.rad {return false}
    if lhs._motionProf != rhs._motionProf {return false}
    if lhs.idTag != rhs.idTag {return false}
    if lhs.numRetries != rhs.numRetries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_GoToPoseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GoToPoseResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_GoToPoseResponse, rhs: Anki_Vector_ExternalInterface_GoToPoseResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DockWithCubeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DockWithCubeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .standard(proto: "distance_from_marker_mm"),
    3: .standard(proto: "approach_angle_rad"),
    4: .standard(proto: "alignment_type"),
    5: .standard(proto: "use_approach_angle"),
    6: .standard(proto: "use_pre_dock_pose"),
    7: .standard(proto: "motion_prof"),
    8: .standard(proto: "id_tag"),
    9: .standard(proto: "num_retries"),
  ]

  fileprivate class _StorageClass {
    var _objectID: Int32 = 0
    var _distanceFromMarkerMm: Float = 0
    var _approachAngleRad: Float = 0
    var _alignmentType: Anki_Vector_ExternalInterface_AlignmentType = .unknown
    var _useApproachAngle: Bool = false
    var _usePreDockPose: Bool = false
    var _motionProf: Anki_Vector_ExternalInterface_PathMotionProfile? = nil
    var _idTag: Int32 = 0
    var _numRetries: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _objectID = source._objectID
      _distanceFromMarkerMm = source._distanceFromMarkerMm
      _approachAngleRad = source._approachAngleRad
      _alignmentType = source._alignmentType
      _useApproachAngle = source._useApproachAngle
      _usePreDockPose = source._usePreDockPose
      _motionProf = source._motionProf
      _idTag = source._idTag
      _numRetries = source._numRetries
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._objectID) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._distanceFromMarkerMm) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._approachAngleRad) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._alignmentType) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._useApproachAngle) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._usePreDockPose) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._motionProf) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._idTag) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._numRetries) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._objectID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._objectID, fieldNumber: 1)
      }
      if _storage._distanceFromMarkerMm != 0 {
        try visitor.visitSingularFloatField(value: _storage._distanceFromMarkerMm, fieldNumber: 2)
      }
      if _storage._approachAngleRad != 0 {
        try visitor.visitSingularFloatField(value: _storage._approachAngleRad, fieldNumber: 3)
      }
      if _storage._alignmentType != .unknown {
        try visitor.visitSingularEnumField(value: _storage._alignmentType, fieldNumber: 4)
      }
      if _storage._useApproachAngle != false {
        try visitor.visitSingularBoolField(value: _storage._useApproachAngle, fieldNumber: 5)
      }
      if _storage._usePreDockPose != false {
        try visitor.visitSingularBoolField(value: _storage._usePreDockPose, fieldNumber: 6)
      }
      try { if let v = _storage._motionProf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._idTag != 0 {
        try visitor.visitSingularInt32Field(value: _storage._idTag, fieldNumber: 8)
      }
      if _storage._numRetries != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numRetries, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DockWithCubeRequest, rhs: Anki_Vector_ExternalInterface_DockWithCubeRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._objectID != rhs_storage._objectID {return false}
        if _storage._distanceFromMarkerMm != rhs_storage._distanceFromMarkerMm {return false}
        if _storage._approachAngleRad != rhs_storage._approachAngleRad {return false}
        if _storage._alignmentType != rhs_storage._alignmentType {return false}
        if _storage._useApproachAngle != rhs_storage._useApproachAngle {return false}
        if _storage._usePreDockPose != rhs_storage._usePreDockPose {return false}
        if _storage._motionProf != rhs_storage._motionProf {return false}
        if _storage._idTag != rhs_storage._idTag {return false}
        if _storage._numRetries != rhs_storage._numRetries {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DockWithCubeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DockWithCubeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DockWithCubeResponse, rhs: Anki_Vector_ExternalInterface_DockWithCubeResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DriveStraightRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DriveStraightRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "speed_mmps"),
    2: .standard(proto: "dist_mm"),
    3: .standard(proto: "should_play_animation"),
    4: .standard(proto: "id_tag"),
    5: .standard(proto: "num_retries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.speedMmps) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.distMm) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.shouldPlayAnimation) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.idTag) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.numRetries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.speedMmps != 0 {
      try visitor.visitSingularFloatField(value: self.speedMmps, fieldNumber: 1)
    }
    if self.distMm != 0 {
      try visitor.visitSingularFloatField(value: self.distMm, fieldNumber: 2)
    }
    if self.shouldPlayAnimation != false {
      try visitor.visitSingularBoolField(value: self.shouldPlayAnimation, fieldNumber: 3)
    }
    if self.idTag != 0 {
      try visitor.visitSingularInt32Field(value: self.idTag, fieldNumber: 4)
    }
    if self.numRetries != 0 {
      try visitor.visitSingularInt32Field(value: self.numRetries, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DriveStraightRequest, rhs: Anki_Vector_ExternalInterface_DriveStraightRequest) -> Bool {
    if lhs.speedMmps != rhs.speedMmps {return false}
    if lhs.distMm != rhs.distMm {return false}
    if lhs.shouldPlayAnimation != rhs.shouldPlayAnimation {return false}
    if lhs.idTag != rhs.idTag {return false}
    if lhs.numRetries != rhs.numRetries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DriveStraightResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DriveStraightResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DriveStraightResponse, rhs: Anki_Vector_ExternalInterface_DriveStraightResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_TurnInPlaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TurnInPlaceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "angle_rad"),
    2: .standard(proto: "speed_rad_per_sec"),
    3: .standard(proto: "accel_rad_per_sec2"),
    4: .standard(proto: "tol_rad"),
    5: .standard(proto: "is_absolute"),
    6: .standard(proto: "id_tag"),
    7: .standard(proto: "num_retries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.angleRad) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.speedRadPerSec) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.accelRadPerSec2) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.tolRad) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.isAbsolute) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.idTag) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.numRetries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.angleRad != 0 {
      try visitor.visitSingularFloatField(value: self.angleRad, fieldNumber: 1)
    }
    if self.speedRadPerSec != 0 {
      try visitor.visitSingularFloatField(value: self.speedRadPerSec, fieldNumber: 2)
    }
    if self.accelRadPerSec2 != 0 {
      try visitor.visitSingularFloatField(value: self.accelRadPerSec2, fieldNumber: 3)
    }
    if self.tolRad != 0 {
      try visitor.visitSingularFloatField(value: self.tolRad, fieldNumber: 4)
    }
    if self.isAbsolute != 0 {
      try visitor.visitSingularUInt32Field(value: self.isAbsolute, fieldNumber: 5)
    }
    if self.idTag != 0 {
      try visitor.visitSingularInt32Field(value: self.idTag, fieldNumber: 6)
    }
    if self.numRetries != 0 {
      try visitor.visitSingularInt32Field(value: self.numRetries, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_TurnInPlaceRequest, rhs: Anki_Vector_ExternalInterface_TurnInPlaceRequest) -> Bool {
    if lhs.angleRad != rhs.angleRad {return false}
    if lhs.speedRadPerSec != rhs.speedRadPerSec {return false}
    if lhs.accelRadPerSec2 != rhs.accelRadPerSec2 {return false}
    if lhs.tolRad != rhs.tolRad {return false}
    if lhs.isAbsolute != rhs.isAbsolute {return false}
    if lhs.idTag != rhs.idTag {return false}
    if lhs.numRetries != rhs.numRetries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_TurnInPlaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TurnInPlaceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_TurnInPlaceResponse, rhs: Anki_Vector_ExternalInterface_TurnInPlaceResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SetHeadAngleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetHeadAngleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "angle_rad"),
    2: .standard(proto: "max_speed_rad_per_sec"),
    3: .standard(proto: "accel_rad_per_sec2"),
    4: .standard(proto: "duration_sec"),
    5: .standard(proto: "id_tag"),
    6: .standard(proto: "num_retries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.angleRad) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.maxSpeedRadPerSec) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.accelRadPerSec2) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.durationSec) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.idTag) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.numRetries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.angleRad != 0 {
      try visitor.visitSingularFloatField(value: self.angleRad, fieldNumber: 1)
    }
    if self.maxSpeedRadPerSec != 0 {
      try visitor.visitSingularFloatField(value: self.maxSpeedRadPerSec, fieldNumber: 2)
    }
    if self.accelRadPerSec2 != 0 {
      try visitor.visitSingularFloatField(value: self.accelRadPerSec2, fieldNumber: 3)
    }
    if self.durationSec != 0 {
      try visitor.visitSingularFloatField(value: self.durationSec, fieldNumber: 4)
    }
    if self.idTag != 0 {
      try visitor.visitSingularInt32Field(value: self.idTag, fieldNumber: 5)
    }
    if self.numRetries != 0 {
      try visitor.visitSingularInt32Field(value: self.numRetries, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SetHeadAngleRequest, rhs: Anki_Vector_ExternalInterface_SetHeadAngleRequest) -> Bool {
    if lhs.angleRad != rhs.angleRad {return false}
    if lhs.maxSpeedRadPerSec != rhs.maxSpeedRadPerSec {return false}
    if lhs.accelRadPerSec2 != rhs.accelRadPerSec2 {return false}
    if lhs.durationSec != rhs.durationSec {return false}
    if lhs.idTag != rhs.idTag {return false}
    if lhs.numRetries != rhs.numRetries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SetHeadAngleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetHeadAngleResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SetHeadAngleResponse, rhs: Anki_Vector_ExternalInterface_SetHeadAngleResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SetLiftHeightRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetLiftHeightRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "height_mm"),
    2: .standard(proto: "max_speed_rad_per_sec"),
    3: .standard(proto: "accel_rad_per_sec2"),
    4: .standard(proto: "duration_sec"),
    5: .standard(proto: "id_tag"),
    6: .standard(proto: "num_retries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.heightMm) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.maxSpeedRadPerSec) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.accelRadPerSec2) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.durationSec) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.idTag) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.numRetries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.heightMm != 0 {
      try visitor.visitSingularFloatField(value: self.heightMm, fieldNumber: 1)
    }
    if self.maxSpeedRadPerSec != 0 {
      try visitor.visitSingularFloatField(value: self.maxSpeedRadPerSec, fieldNumber: 2)
    }
    if self.accelRadPerSec2 != 0 {
      try visitor.visitSingularFloatField(value: self.accelRadPerSec2, fieldNumber: 3)
    }
    if self.durationSec != 0 {
      try visitor.visitSingularFloatField(value: self.durationSec, fieldNumber: 4)
    }
    if self.idTag != 0 {
      try visitor.visitSingularInt32Field(value: self.idTag, fieldNumber: 5)
    }
    if self.numRetries != 0 {
      try visitor.visitSingularInt32Field(value: self.numRetries, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SetLiftHeightRequest, rhs: Anki_Vector_ExternalInterface_SetLiftHeightRequest) -> Bool {
    if lhs.heightMm != rhs.heightMm {return false}
    if lhs.maxSpeedRadPerSec != rhs.maxSpeedRadPerSec {return false}
    if lhs.accelRadPerSec2 != rhs.accelRadPerSec2 {return false}
    if lhs.durationSec != rhs.durationSec {return false}
    if lhs.idTag != rhs.idTag {return false}
    if lhs.numRetries != rhs.numRetries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SetLiftHeightResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetLiftHeightResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SetLiftHeightResponse, rhs: Anki_Vector_ExternalInterface_SetLiftHeightResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_TurnTowardsFaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TurnTowardsFaceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "face_id"),
    2: .standard(proto: "max_turn_angle_rad"),
    3: .standard(proto: "id_tag"),
    4: .standard(proto: "num_retries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.faceID) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.maxTurnAngleRad) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.idTag) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.numRetries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.faceID != 0 {
      try visitor.visitSingularInt32Field(value: self.faceID, fieldNumber: 1)
    }
    if self.maxTurnAngleRad != 0 {
      try visitor.visitSingularFloatField(value: self.maxTurnAngleRad, fieldNumber: 2)
    }
    if self.idTag != 0 {
      try visitor.visitSingularInt32Field(value: self.idTag, fieldNumber: 3)
    }
    if self.numRetries != 0 {
      try visitor.visitSingularInt32Field(value: self.numRetries, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_TurnTowardsFaceRequest, rhs: Anki_Vector_ExternalInterface_TurnTowardsFaceRequest) -> Bool {
    if lhs.faceID != rhs.faceID {return false}
    if lhs.maxTurnAngleRad != rhs.maxTurnAngleRad {return false}
    if lhs.idTag != rhs.idTag {return false}
    if lhs.numRetries != rhs.numRetries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_TurnTowardsFaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TurnTowardsFaceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_TurnTowardsFaceResponse, rhs: Anki_Vector_ExternalInterface_TurnTowardsFaceResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_GoToObjectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GoToObjectRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .standard(proto: "motion_prof"),
    3: .standard(proto: "distance_from_object_origin_mm"),
    4: .standard(proto: "use_pre_dock_pose"),
    5: .standard(proto: "id_tag"),
    6: .standard(proto: "num_retries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._motionProf) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.distanceFromObjectOriginMm) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.usePreDockPose) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.idTag) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.numRetries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.objectID != 0 {
      try visitor.visitSingularInt32Field(value: self.objectID, fieldNumber: 1)
    }
    try { if let v = self._motionProf {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.distanceFromObjectOriginMm != 0 {
      try visitor.visitSingularFloatField(value: self.distanceFromObjectOriginMm, fieldNumber: 3)
    }
    if self.usePreDockPose != false {
      try visitor.visitSingularBoolField(value: self.usePreDockPose, fieldNumber: 4)
    }
    if self.idTag != 0 {
      try visitor.visitSingularInt32Field(value: self.idTag, fieldNumber: 5)
    }
    if self.numRetries != 0 {
      try visitor.visitSingularInt32Field(value: self.numRetries, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_GoToObjectRequest, rhs: Anki_Vector_ExternalInterface_GoToObjectRequest) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs._motionProf != rhs._motionProf {return false}
    if lhs.distanceFromObjectOriginMm != rhs.distanceFromObjectOriginMm {return false}
    if lhs.usePreDockPose != rhs.usePreDockPose {return false}
    if lhs.idTag != rhs.idTag {return false}
    if lhs.numRetries != rhs.numRetries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_GoToObjectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GoToObjectResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_GoToObjectResponse, rhs: Anki_Vector_ExternalInterface_GoToObjectResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_RollObjectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollObjectRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .standard(proto: "motion_prof"),
    3: .standard(proto: "approach_angle_rad"),
    4: .standard(proto: "use_approach_angle"),
    5: .standard(proto: "use_pre_dock_pose"),
    6: .standard(proto: "id_tag"),
    7: .standard(proto: "num_retries"),
  ]

  fileprivate class _StorageClass {
    var _objectID: Int32 = 0
    var _motionProf: Anki_Vector_ExternalInterface_PathMotionProfile? = nil
    var _approachAngleRad: Float = 0
    var _useApproachAngle: Bool = false
    var _usePreDockPose: Bool = false
    var _idTag: Int32 = 0
    var _numRetries: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _objectID = source._objectID
      _motionProf = source._motionProf
      _approachAngleRad = source._approachAngleRad
      _useApproachAngle = source._useApproachAngle
      _usePreDockPose = source._usePreDockPose
      _idTag = source._idTag
      _numRetries = source._numRetries
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._objectID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._motionProf) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._approachAngleRad) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._useApproachAngle) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._usePreDockPose) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._idTag) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._numRetries) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._objectID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._objectID, fieldNumber: 1)
      }
      try { if let v = _storage._motionProf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._approachAngleRad != 0 {
        try visitor.visitSingularFloatField(value: _storage._approachAngleRad, fieldNumber: 3)
      }
      if _storage._useApproachAngle != false {
        try visitor.visitSingularBoolField(value: _storage._useApproachAngle, fieldNumber: 4)
      }
      if _storage._usePreDockPose != false {
        try visitor.visitSingularBoolField(value: _storage._usePreDockPose, fieldNumber: 5)
      }
      if _storage._idTag != 0 {
        try visitor.visitSingularInt32Field(value: _storage._idTag, fieldNumber: 6)
      }
      if _storage._numRetries != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numRetries, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_RollObjectRequest, rhs: Anki_Vector_ExternalInterface_RollObjectRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._objectID != rhs_storage._objectID {return false}
        if _storage._motionProf != rhs_storage._motionProf {return false}
        if _storage._approachAngleRad != rhs_storage._approachAngleRad {return false}
        if _storage._useApproachAngle != rhs_storage._useApproachAngle {return false}
        if _storage._usePreDockPose != rhs_storage._usePreDockPose {return false}
        if _storage._idTag != rhs_storage._idTag {return false}
        if _storage._numRetries != rhs_storage._numRetries {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_RollObjectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollObjectResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_RollObjectResponse, rhs: Anki_Vector_ExternalInterface_RollObjectResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PopAWheelieRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PopAWheelieRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .standard(proto: "motion_prof"),
    3: .standard(proto: "approach_angle_rad"),
    4: .standard(proto: "use_approach_angle"),
    5: .standard(proto: "use_pre_dock_pose"),
    6: .standard(proto: "id_tag"),
    7: .standard(proto: "num_retries"),
  ]

  fileprivate class _StorageClass {
    var _objectID: Int32 = 0
    var _motionProf: Anki_Vector_ExternalInterface_PathMotionProfile? = nil
    var _approachAngleRad: Float = 0
    var _useApproachAngle: Bool = false
    var _usePreDockPose: Bool = false
    var _idTag: Int32 = 0
    var _numRetries: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _objectID = source._objectID
      _motionProf = source._motionProf
      _approachAngleRad = source._approachAngleRad
      _useApproachAngle = source._useApproachAngle
      _usePreDockPose = source._usePreDockPose
      _idTag = source._idTag
      _numRetries = source._numRetries
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._objectID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._motionProf) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._approachAngleRad) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._useApproachAngle) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._usePreDockPose) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._idTag) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._numRetries) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._objectID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._objectID, fieldNumber: 1)
      }
      try { if let v = _storage._motionProf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._approachAngleRad != 0 {
        try visitor.visitSingularFloatField(value: _storage._approachAngleRad, fieldNumber: 3)
      }
      if _storage._useApproachAngle != false {
        try visitor.visitSingularBoolField(value: _storage._useApproachAngle, fieldNumber: 4)
      }
      if _storage._usePreDockPose != false {
        try visitor.visitSingularBoolField(value: _storage._usePreDockPose, fieldNumber: 5)
      }
      if _storage._idTag != 0 {
        try visitor.visitSingularInt32Field(value: _storage._idTag, fieldNumber: 6)
      }
      if _storage._numRetries != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numRetries, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PopAWheelieRequest, rhs: Anki_Vector_ExternalInterface_PopAWheelieRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._objectID != rhs_storage._objectID {return false}
        if _storage._motionProf != rhs_storage._motionProf {return false}
        if _storage._approachAngleRad != rhs_storage._approachAngleRad {return false}
        if _storage._useApproachAngle != rhs_storage._useApproachAngle {return false}
        if _storage._usePreDockPose != rhs_storage._usePreDockPose {return false}
        if _storage._idTag != rhs_storage._idTag {return false}
        if _storage._numRetries != rhs_storage._numRetries {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PopAWheelieResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PopAWheelieResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PopAWheelieResponse, rhs: Anki_Vector_ExternalInterface_PopAWheelieResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PickupObjectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PickupObjectRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .standard(proto: "motion_prof"),
    3: .standard(proto: "approach_angle_rad"),
    4: .standard(proto: "use_approach_angle"),
    5: .standard(proto: "use_pre_dock_pose"),
    6: .standard(proto: "id_tag"),
    7: .standard(proto: "num_retries"),
  ]

  fileprivate class _StorageClass {
    var _objectID: Int32 = 0
    var _motionProf: Anki_Vector_ExternalInterface_PathMotionProfile? = nil
    var _approachAngleRad: Float = 0
    var _useApproachAngle: Bool = false
    var _usePreDockPose: Bool = false
    var _idTag: Int32 = 0
    var _numRetries: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _objectID = source._objectID
      _motionProf = source._motionProf
      _approachAngleRad = source._approachAngleRad
      _useApproachAngle = source._useApproachAngle
      _usePreDockPose = source._usePreDockPose
      _idTag = source._idTag
      _numRetries = source._numRetries
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._objectID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._motionProf) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._approachAngleRad) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._useApproachAngle) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._usePreDockPose) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._idTag) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._numRetries) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._objectID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._objectID, fieldNumber: 1)
      }
      try { if let v = _storage._motionProf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._approachAngleRad != 0 {
        try visitor.visitSingularFloatField(value: _storage._approachAngleRad, fieldNumber: 3)
      }
      if _storage._useApproachAngle != false {
        try visitor.visitSingularBoolField(value: _storage._useApproachAngle, fieldNumber: 4)
      }
      if _storage._usePreDockPose != false {
        try visitor.visitSingularBoolField(value: _storage._usePreDockPose, fieldNumber: 5)
      }
      if _storage._idTag != 0 {
        try visitor.visitSingularInt32Field(value: _storage._idTag, fieldNumber: 6)
      }
      if _storage._numRetries != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numRetries, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PickupObjectRequest, rhs: Anki_Vector_ExternalInterface_PickupObjectRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._objectID != rhs_storage._objectID {return false}
        if _storage._motionProf != rhs_storage._motionProf {return false}
        if _storage._approachAngleRad != rhs_storage._approachAngleRad {return false}
        if _storage._useApproachAngle != rhs_storage._useApproachAngle {return false}
        if _storage._usePreDockPose != rhs_storage._usePreDockPose {return false}
        if _storage._idTag != rhs_storage._idTag {return false}
        if _storage._numRetries != rhs_storage._numRetries {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PickupObjectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PickupObjectResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PickupObjectResponse, rhs: Anki_Vector_ExternalInterface_PickupObjectResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PlaceObjectOnGroundHereRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlaceObjectOnGroundHereRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_tag"),
    2: .standard(proto: "num_retries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.idTag) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.numRetries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.idTag != 0 {
      try visitor.visitSingularInt32Field(value: self.idTag, fieldNumber: 1)
    }
    if self.numRetries != 0 {
      try visitor.visitSingularInt32Field(value: self.numRetries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PlaceObjectOnGroundHereRequest, rhs: Anki_Vector_ExternalInterface_PlaceObjectOnGroundHereRequest) -> Bool {
    if lhs.idTag != rhs.idTag {return false}
    if lhs.numRetries != rhs.numRetries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_PlaceObjectOnGroundHereResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlaceObjectOnGroundHereResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_PlaceObjectOnGroundHereResponse, rhs: Anki_Vector_ExternalInterface_PlaceObjectOnGroundHereResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_BatteryStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatteryStateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_BatteryStateRequest, rhs: Anki_Vector_ExternalInterface_BatteryStateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_BatteryStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatteryStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "battery_level"),
    3: .standard(proto: "battery_volts"),
    4: .standard(proto: "is_charging"),
    5: .standard(proto: "is_on_charger_platform"),
    6: .standard(proto: "suggested_charger_sec"),
    7: .standard(proto: "cube_battery"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.batteryLevel) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.batteryVolts) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isCharging) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isOnChargerPlatform) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.suggestedChargerSec) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._cubeBattery) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.batteryLevel != .unknown {
      try visitor.visitSingularEnumField(value: self.batteryLevel, fieldNumber: 2)
    }
    if self.batteryVolts != 0 {
      try visitor.visitSingularFloatField(value: self.batteryVolts, fieldNumber: 3)
    }
    if self.isCharging != false {
      try visitor.visitSingularBoolField(value: self.isCharging, fieldNumber: 4)
    }
    if self.isOnChargerPlatform != false {
      try visitor.visitSingularBoolField(value: self.isOnChargerPlatform, fieldNumber: 5)
    }
    if self.suggestedChargerSec != 0 {
      try visitor.visitSingularFloatField(value: self.suggestedChargerSec, fieldNumber: 6)
    }
    try { if let v = self._cubeBattery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_BatteryStateResponse, rhs: Anki_Vector_ExternalInterface_BatteryStateResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.batteryLevel != rhs.batteryLevel {return false}
    if lhs.batteryVolts != rhs.batteryVolts {return false}
    if lhs.isCharging != rhs.isCharging {return false}
    if lhs.isOnChargerPlatform != rhs.isOnChargerPlatform {return false}
    if lhs.suggestedChargerSec != rhs.suggestedChargerSec {return false}
    if lhs._cubeBattery != rhs._cubeBattery {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CubeBattery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CubeBattery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "level"),
    2: .standard(proto: "factory_id"),
    3: .standard(proto: "battery_volts"),
    4: .standard(proto: "time_since_last_reading_sec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.level) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.factoryID) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.batteryVolts) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.timeSinceLastReadingSec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.level != .low {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 1)
    }
    if !self.factoryID.isEmpty {
      try visitor.visitSingularStringField(value: self.factoryID, fieldNumber: 2)
    }
    if self.batteryVolts != 0 {
      try visitor.visitSingularFloatField(value: self.batteryVolts, fieldNumber: 3)
    }
    if self.timeSinceLastReadingSec != 0 {
      try visitor.visitSingularFloatField(value: self.timeSinceLastReadingSec, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CubeBattery, rhs: Anki_Vector_ExternalInterface_CubeBattery) -> Bool {
    if lhs.level != rhs.level {return false}
    if lhs.factoryID != rhs.factoryID {return false}
    if lhs.batteryVolts != rhs.batteryVolts {return false}
    if lhs.timeSinceLastReadingSec != rhs.timeSinceLastReadingSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CubeBattery.CubeBatteryLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Low"),
    1: .same(proto: "Normal"),
  ]
}

extension Anki_Vector_ExternalInterface_VersionStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionStateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_VersionStateRequest, rhs: Anki_Vector_ExternalInterface_VersionStateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_VersionStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "os_version"),
    3: .standard(proto: "engine_build_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.engineBuildID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 2)
    }
    if !self.engineBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.engineBuildID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_VersionStateResponse, rhs: Anki_Vector_ExternalInterface_VersionStateResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.engineBuildID != rhs.engineBuildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SayTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SayTextRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "use_vector_voice"),
    3: .standard(proto: "duration_scalar"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.useVectorVoice) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.durationScalar) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.useVectorVoice != false {
      try visitor.visitSingularBoolField(value: self.useVectorVoice, fieldNumber: 2)
    }
    if self.durationScalar != 0 {
      try visitor.visitSingularFloatField(value: self.durationScalar, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SayTextRequest, rhs: Anki_Vector_ExternalInterface_SayTextRequest) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.useVectorVoice != rhs.useVectorVoice {return false}
    if lhs.durationScalar != rhs.durationScalar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SayTextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SayTextResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.state != .invalid {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SayTextResponse, rhs: Anki_Vector_ExternalInterface_SayTextResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SayTextResponse.UtteranceState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID"),
    1: .same(proto: "GENERATING"),
    2: .same(proto: "READY"),
    3: .same(proto: "PLAYING"),
    4: .same(proto: "FINISHED"),
  ]
}

extension Anki_Vector_ExternalInterface_StimulationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StimulationInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "emotion_events"),
    2: .same(proto: "value"),
    3: .same(proto: "velocity"),
    4: .same(proto: "accel"),
    5: .standard(proto: "value_before_event"),
    6: .standard(proto: "min_value"),
    7: .standard(proto: "max_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.emotionEvents) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.velocity) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.accel) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.valueBeforeEvent) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.minValue) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.maxValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.emotionEvents.isEmpty {
      try visitor.visitRepeatedStringField(value: self.emotionEvents, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 2)
    }
    if self.velocity != 0 {
      try visitor.visitSingularFloatField(value: self.velocity, fieldNumber: 3)
    }
    if self.accel != 0 {
      try visitor.visitSingularFloatField(value: self.accel, fieldNumber: 4)
    }
    if self.valueBeforeEvent != 0 {
      try visitor.visitSingularFloatField(value: self.valueBeforeEvent, fieldNumber: 5)
    }
    if self.minValue != 0 {
      try visitor.visitSingularFloatField(value: self.minValue, fieldNumber: 6)
    }
    if self.maxValue != 0 {
      try visitor.visitSingularFloatField(value: self.maxValue, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_StimulationInfo, rhs: Anki_Vector_ExternalInterface_StimulationInfo) -> Bool {
    if lhs.emotionEvents != rhs.emotionEvents {return false}
    if lhs.value != rhs.value {return false}
    if lhs.velocity != rhs.velocity {return false}
    if lhs.accel != rhs.accel {return false}
    if lhs.valueBeforeEvent != rhs.valueBeforeEvent {return false}
    if lhs.minValue != rhs.minValue {return false}
    if lhs.maxValue != rhs.maxValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_AudioSendModeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioSendModeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .audioUnknown {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_AudioSendModeRequest, rhs: Anki_Vector_ExternalInterface_AudioSendModeRequest) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_AudioSendModeChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioSendModeChanged"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .audioUnknown {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_AudioSendModeChanged, rhs: Anki_Vector_ExternalInterface_AudioSendModeChanged) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_AudioChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioChunk"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "robot_time_stamp"),
    2: .standard(proto: "group_id"),
    3: .standard(proto: "chunk_id"),
    4: .standard(proto: "audio_chunk_count"),
    5: .standard(proto: "signal_power"),
    6: .standard(proto: "direction_strengths"),
    7: .standard(proto: "source_direction"),
    8: .standard(proto: "source_confidence"),
    9: .standard(proto: "noise_floor_power"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.robotTimeStamp) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.chunkID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.audioChunkCount) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.signalPower) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.directionStrengths) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.sourceDirection) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.sourceConfidence) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.noiseFloorPower) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.robotTimeStamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.robotTimeStamp, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularUInt32Field(value: self.groupID, fieldNumber: 2)
    }
    if self.chunkID != 0 {
      try visitor.visitSingularUInt32Field(value: self.chunkID, fieldNumber: 3)
    }
    if self.audioChunkCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.audioChunkCount, fieldNumber: 4)
    }
    if !self.signalPower.isEmpty {
      try visitor.visitSingularBytesField(value: self.signalPower, fieldNumber: 5)
    }
    if !self.directionStrengths.isEmpty {
      try visitor.visitSingularBytesField(value: self.directionStrengths, fieldNumber: 6)
    }
    if self.sourceDirection != 0 {
      try visitor.visitSingularUInt32Field(value: self.sourceDirection, fieldNumber: 7)
    }
    if self.sourceConfidence != 0 {
      try visitor.visitSingularUInt32Field(value: self.sourceConfidence, fieldNumber: 8)
    }
    if self.noiseFloorPower != 0 {
      try visitor.visitSingularUInt32Field(value: self.noiseFloorPower, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_AudioChunk, rhs: Anki_Vector_ExternalInterface_AudioChunk) -> Bool {
    if lhs.robotTimeStamp != rhs.robotTimeStamp {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.chunkID != rhs.chunkID {return false}
    if lhs.audioChunkCount != rhs.audioChunkCount {return false}
    if lhs.signalPower != rhs.signalPower {return false}
    if lhs.directionStrengths != rhs.directionStrengths {return false}
    if lhs.sourceDirection != rhs.sourceDirection {return false}
    if lhs.sourceConfidence != rhs.sourceConfidence {return false}
    if lhs.noiseFloorPower != rhs.noiseFloorPower {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_AudioFeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioFeedRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_AudioFeedRequest, rhs: Anki_Vector_ExternalInterface_AudioFeedRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_AudioFeedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioFeedResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "robot_time_stamp"),
    2: .standard(proto: "group_id"),
    3: .standard(proto: "signal_power"),
    4: .standard(proto: "direction_strengths"),
    5: .standard(proto: "source_direction"),
    6: .standard(proto: "source_confidence"),
    7: .standard(proto: "noise_floor_power"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.robotTimeStamp) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.signalPower) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.directionStrengths) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.sourceDirection) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.sourceConfidence) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.noiseFloorPower) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.robotTimeStamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.robotTimeStamp, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularUInt32Field(value: self.groupID, fieldNumber: 2)
    }
    if !self.signalPower.isEmpty {
      try visitor.visitSingularBytesField(value: self.signalPower, fieldNumber: 3)
    }
    if !self.directionStrengths.isEmpty {
      try visitor.visitSingularBytesField(value: self.directionStrengths, fieldNumber: 4)
    }
    if self.sourceDirection != 0 {
      try visitor.visitSingularUInt32Field(value: self.sourceDirection, fieldNumber: 5)
    }
    if self.sourceConfidence != 0 {
      try visitor.visitSingularUInt32Field(value: self.sourceConfidence, fieldNumber: 6)
    }
    if self.noiseFloorPower != 0 {
      try visitor.visitSingularUInt32Field(value: self.noiseFloorPower, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_AudioFeedResponse, rhs: Anki_Vector_ExternalInterface_AudioFeedResponse) -> Bool {
    if lhs.robotTimeStamp != rhs.robotTimeStamp {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.signalPower != rhs.signalPower {return false}
    if lhs.directionStrengths != rhs.directionStrengths {return false}
    if lhs.sourceDirection != rhs.sourceDirection {return false}
    if lhs.sourceConfidence != rhs.sourceConfidence {return false}
    if lhs.noiseFloorPower != rhs.noiseFloorPower {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ExternalAudioStreamPrepare: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalAudioStreamPrepare"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_frame_rate"),
    2: .standard(proto: "audio_volume"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.audioFrameRate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.audioVolume) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.audioFrameRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.audioFrameRate, fieldNumber: 1)
    }
    if self.audioVolume != 0 {
      try visitor.visitSingularUInt32Field(value: self.audioVolume, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ExternalAudioStreamPrepare, rhs: Anki_Vector_ExternalInterface_ExternalAudioStreamPrepare) -> Bool {
    if lhs.audioFrameRate != rhs.audioFrameRate {return false}
    if lhs.audioVolume != rhs.audioVolume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ExternalAudioStreamChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalAudioStreamChunk"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_chunk_size_bytes"),
    2: .standard(proto: "audio_chunk_samples"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.audioChunkSizeBytes) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.audioChunkSamples) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.audioChunkSizeBytes != 0 {
      try visitor.visitSingularUInt32Field(value: self.audioChunkSizeBytes, fieldNumber: 1)
    }
    if !self.audioChunkSamples.isEmpty {
      try visitor.visitSingularBytesField(value: self.audioChunkSamples, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ExternalAudioStreamChunk, rhs: Anki_Vector_ExternalInterface_ExternalAudioStreamChunk) -> Bool {
    if lhs.audioChunkSizeBytes != rhs.audioChunkSizeBytes {return false}
    if lhs.audioChunkSamples != rhs.audioChunkSamples {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ExternalAudioStreamComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalAudioStreamComplete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ExternalAudioStreamComplete, rhs: Anki_Vector_ExternalInterface_ExternalAudioStreamComplete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ExternalAudioStreamCancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalAudioStreamCancel"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ExternalAudioStreamCancel, rhs: Anki_Vector_ExternalInterface_ExternalAudioStreamCancel) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ExternalAudioStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalAudioStreamRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_stream_prepare"),
    2: .standard(proto: "audio_stream_chunk"),
    3: .standard(proto: "audio_stream_complete"),
    4: .standard(proto: "audio_stream_cancel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Anki_Vector_ExternalInterface_ExternalAudioStreamPrepare?
        var hadOneofValue = false
        if let current = self.audioRequestType {
          hadOneofValue = true
          if case .audioStreamPrepare(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.audioRequestType = .audioStreamPrepare(v)
        }
      }()
      case 2: try {
        var v: Anki_Vector_ExternalInterface_ExternalAudioStreamChunk?
        var hadOneofValue = false
        if let current = self.audioRequestType {
          hadOneofValue = true
          if case .audioStreamChunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.audioRequestType = .audioStreamChunk(v)
        }
      }()
      case 3: try {
        var v: Anki_Vector_ExternalInterface_ExternalAudioStreamComplete?
        var hadOneofValue = false
        if let current = self.audioRequestType {
          hadOneofValue = true
          if case .audioStreamComplete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.audioRequestType = .audioStreamComplete(v)
        }
      }()
      case 4: try {
        var v: Anki_Vector_ExternalInterface_ExternalAudioStreamCancel?
        var hadOneofValue = false
        if let current = self.audioRequestType {
          hadOneofValue = true
          if case .audioStreamCancel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.audioRequestType = .audioStreamCancel(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.audioRequestType {
    case .audioStreamPrepare?: try {
      guard case .audioStreamPrepare(let v)? = self.audioRequestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .audioStreamChunk?: try {
      guard case .audioStreamChunk(let v)? = self.audioRequestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .audioStreamComplete?: try {
      guard case .audioStreamComplete(let v)? = self.audioRequestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .audioStreamCancel?: try {
      guard case .audioStreamCancel(let v)? = self.audioRequestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ExternalAudioStreamRequest, rhs: Anki_Vector_ExternalInterface_ExternalAudioStreamRequest) -> Bool {
    if lhs.audioRequestType != rhs.audioRequestType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalAudioStreamPlaybackComplete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackComplete, rhs: Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackComplete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalAudioStreamPlaybackFailure"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackFailure, rhs: Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackFailure) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ExternalAudioStreamBufferOverrun: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalAudioStreamBufferOverrun"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_samples_sent"),
    2: .standard(proto: "audio_samples_played"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.audioSamplesSent) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.audioSamplesPlayed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.audioSamplesSent != 0 {
      try visitor.visitSingularUInt32Field(value: self.audioSamplesSent, fieldNumber: 1)
    }
    if self.audioSamplesPlayed != 0 {
      try visitor.visitSingularUInt32Field(value: self.audioSamplesPlayed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ExternalAudioStreamBufferOverrun, rhs: Anki_Vector_ExternalInterface_ExternalAudioStreamBufferOverrun) -> Bool {
    if lhs.audioSamplesSent != rhs.audioSamplesSent {return false}
    if lhs.audioSamplesPlayed != rhs.audioSamplesPlayed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ExternalAudioStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalAudioStreamResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_stream_playback_complete"),
    2: .standard(proto: "audio_stream_buffer_overrun"),
    3: .standard(proto: "audio_stream_playback_failyer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackComplete?
        var hadOneofValue = false
        if let current = self.audioResponseType {
          hadOneofValue = true
          if case .audioStreamPlaybackComplete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.audioResponseType = .audioStreamPlaybackComplete(v)
        }
      }()
      case 2: try {
        var v: Anki_Vector_ExternalInterface_ExternalAudioStreamBufferOverrun?
        var hadOneofValue = false
        if let current = self.audioResponseType {
          hadOneofValue = true
          if case .audioStreamBufferOverrun(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.audioResponseType = .audioStreamBufferOverrun(v)
        }
      }()
      case 3: try {
        var v: Anki_Vector_ExternalInterface_ExternalAudioStreamPlaybackFailure?
        var hadOneofValue = false
        if let current = self.audioResponseType {
          hadOneofValue = true
          if case .audioStreamPlaybackFailyer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.audioResponseType = .audioStreamPlaybackFailyer(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.audioResponseType {
    case .audioStreamPlaybackComplete?: try {
      guard case .audioStreamPlaybackComplete(let v)? = self.audioResponseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .audioStreamBufferOverrun?: try {
      guard case .audioStreamBufferOverrun(let v)? = self.audioResponseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .audioStreamPlaybackFailyer?: try {
      guard case .audioStreamPlaybackFailyer(let v)? = self.audioResponseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ExternalAudioStreamResponse, rhs: Anki_Vector_ExternalInterface_ExternalAudioStreamResponse) -> Bool {
    if lhs.audioResponseType != rhs.audioResponseType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_MasterVolumeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MasterVolumeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "volume_level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.volumeLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.volumeLevel != .volumeLow {
      try visitor.visitSingularEnumField(value: self.volumeLevel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_MasterVolumeRequest, rhs: Anki_Vector_ExternalInterface_MasterVolumeRequest) -> Bool {
    if lhs.volumeLevel != rhs.volumeLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_MasterVolumeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MasterVolumeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_MasterVolumeResponse, rhs: Anki_Vector_ExternalInterface_MasterVolumeResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_EnableMarkerDetectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnableMarkerDetectionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_EnableMarkerDetectionRequest, rhs: Anki_Vector_ExternalInterface_EnableMarkerDetectionRequest) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_EnableMarkerDetectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnableMarkerDetectionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_EnableMarkerDetectionResponse, rhs: Anki_Vector_ExternalInterface_EnableMarkerDetectionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_EnableFaceDetectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnableFaceDetectionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
    2: .standard(proto: "enable_smile_detection"),
    3: .standard(proto: "enable_expression_estimation"),
    4: .standard(proto: "enable_blink_detection"),
    5: .standard(proto: "enable_gaze_detection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enableSmileDetection) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enableExpressionEstimation) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enableBlinkDetection) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enableGazeDetection) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    if self.enableSmileDetection != false {
      try visitor.visitSingularBoolField(value: self.enableSmileDetection, fieldNumber: 2)
    }
    if self.enableExpressionEstimation != false {
      try visitor.visitSingularBoolField(value: self.enableExpressionEstimation, fieldNumber: 3)
    }
    if self.enableBlinkDetection != false {
      try visitor.visitSingularBoolField(value: self.enableBlinkDetection, fieldNumber: 4)
    }
    if self.enableGazeDetection != false {
      try visitor.visitSingularBoolField(value: self.enableGazeDetection, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_EnableFaceDetectionRequest, rhs: Anki_Vector_ExternalInterface_EnableFaceDetectionRequest) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.enableSmileDetection != rhs.enableSmileDetection {return false}
    if lhs.enableExpressionEstimation != rhs.enableExpressionEstimation {return false}
    if lhs.enableBlinkDetection != rhs.enableBlinkDetection {return false}
    if lhs.enableGazeDetection != rhs.enableGazeDetection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_EnableFaceDetectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnableFaceDetectionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_EnableFaceDetectionResponse, rhs: Anki_Vector_ExternalInterface_EnableFaceDetectionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_EnableMotionDetectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnableMotionDetectionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_EnableMotionDetectionRequest, rhs: Anki_Vector_ExternalInterface_EnableMotionDetectionRequest) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_EnableMotionDetectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnableMotionDetectionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_EnableMotionDetectionResponse, rhs: Anki_Vector_ExternalInterface_EnableMotionDetectionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_EnableMirrorModeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnableMirrorModeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_EnableMirrorModeRequest, rhs: Anki_Vector_ExternalInterface_EnableMirrorModeRequest) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_EnableMirrorModeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnableMirrorModeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_EnableMirrorModeResponse, rhs: Anki_Vector_ExternalInterface_EnableMirrorModeResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_MirrorModeDisabled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MirrorModeDisabled"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_MirrorModeDisabled, rhs: Anki_Vector_ExternalInterface_MirrorModeDisabled) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_EnableImageStreamingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnableImageStreamingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_EnableImageStreamingRequest, rhs: Anki_Vector_ExternalInterface_EnableImageStreamingRequest) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_EnableImageStreamingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnableImageStreamingResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_EnableImageStreamingResponse, rhs: Anki_Vector_ExternalInterface_EnableImageStreamingResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_IsImageStreamingEnabledRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsImageStreamingEnabledRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_IsImageStreamingEnabledRequest, rhs: Anki_Vector_ExternalInterface_IsImageStreamingEnabledRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_IsImageStreamingEnabledResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsImageStreamingEnabledResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_image_streaming_enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isImageStreamingEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isImageStreamingEnabled != false {
      try visitor.visitSingularBoolField(value: self.isImageStreamingEnabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_IsImageStreamingEnabledResponse, rhs: Anki_Vector_ExternalInterface_IsImageStreamingEnabledResponse) -> Bool {
    if lhs.isImageStreamingEnabled != rhs.isImageStreamingEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_VisionModesAutoDisabled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VisionModesAutoDisabled"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_VisionModesAutoDisabled, rhs: Anki_Vector_ExternalInterface_VisionModesAutoDisabled) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ImageChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageChunk"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "frame_time_stamp"),
    2: .standard(proto: "image_id"),
    3: .same(proto: "width"),
    4: .same(proto: "height"),
    5: .standard(proto: "image_encoding"),
    6: .standard(proto: "display_index"),
    7: .standard(proto: "image_chunk_count"),
    8: .standard(proto: "chunk_id"),
    9: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.frameTimeStamp) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.imageID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.imageEncoding) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.displayIndex) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.imageChunkCount) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.chunkID) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frameTimeStamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.frameTimeStamp, fieldNumber: 1)
    }
    if self.imageID != 0 {
      try visitor.visitSingularUInt32Field(value: self.imageID, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 4)
    }
    if self.imageEncoding != .noneImageEncoding {
      try visitor.visitSingularEnumField(value: self.imageEncoding, fieldNumber: 5)
    }
    if self.displayIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.displayIndex, fieldNumber: 6)
    }
    if self.imageChunkCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.imageChunkCount, fieldNumber: 7)
    }
    if self.chunkID != 0 {
      try visitor.visitSingularUInt32Field(value: self.chunkID, fieldNumber: 8)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ImageChunk, rhs: Anki_Vector_ExternalInterface_ImageChunk) -> Bool {
    if lhs.frameTimeStamp != rhs.frameTimeStamp {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.imageEncoding != rhs.imageEncoding {return false}
    if lhs.displayIndex != rhs.displayIndex {return false}
    if lhs.imageChunkCount != rhs.imageChunkCount {return false}
    if lhs.chunkID != rhs.chunkID {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ImageChunk.ImageEncoding: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE_IMAGE_ENCODING"),
    1: .same(proto: "RAW_GRAY"),
    2: .same(proto: "RAW_RGB"),
    3: .same(proto: "YUYV"),
    4: .same(proto: "YUV420SP"),
    5: .same(proto: "BAYER"),
    6: .same(proto: "JPEG_GRAY"),
    7: .same(proto: "JPEG_COLOR"),
    8: .same(proto: "JPEG_COLOR_HALF_WIDTH"),
    9: .same(proto: "JPEG_MINIMIZED_GRAY"),
    10: .same(proto: "JPEG_MINIMIZED_COLOR"),
  ]
}

extension Anki_Vector_ExternalInterface_CameraFeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CameraFeedRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CameraFeedRequest, rhs: Anki_Vector_ExternalInterface_CameraFeedRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CameraFeedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CameraFeedResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "frame_time_stamp"),
    2: .standard(proto: "image_id"),
    3: .standard(proto: "image_encoding"),
    4: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.frameTimeStamp) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.imageID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.imageEncoding) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frameTimeStamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.frameTimeStamp, fieldNumber: 1)
    }
    if self.imageID != 0 {
      try visitor.visitSingularUInt32Field(value: self.imageID, fieldNumber: 2)
    }
    if self.imageEncoding != .noneImageEncoding {
      try visitor.visitSingularEnumField(value: self.imageEncoding, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CameraFeedResponse, rhs: Anki_Vector_ExternalInterface_CameraFeedResponse) -> Bool {
    if lhs.frameTimeStamp != rhs.frameTimeStamp {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.imageEncoding != rhs.imageEncoding {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CaptureSingleImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CaptureSingleImageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CaptureSingleImageRequest, rhs: Anki_Vector_ExternalInterface_CaptureSingleImageRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CaptureSingleImageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CaptureSingleImageResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "frame_time_stamp"),
    3: .standard(proto: "image_id"),
    4: .standard(proto: "image_encoding"),
    5: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.frameTimeStamp) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.imageID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.imageEncoding) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.frameTimeStamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.frameTimeStamp, fieldNumber: 2)
    }
    if self.imageID != 0 {
      try visitor.visitSingularUInt32Field(value: self.imageID, fieldNumber: 3)
    }
    if self.imageEncoding != .noneImageEncoding {
      try visitor.visitSingularEnumField(value: self.imageEncoding, fieldNumber: 4)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CaptureSingleImageResponse, rhs: Anki_Vector_ExternalInterface_CaptureSingleImageResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.frameTimeStamp != rhs.frameTimeStamp {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.imageEncoding != rhs.imageEncoding {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SetEyeColorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetEyeColorRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hue"),
    2: .same(proto: "saturation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.hue) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.saturation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hue != 0 {
      try visitor.visitSingularFloatField(value: self.hue, fieldNumber: 1)
    }
    if self.saturation != 0 {
      try visitor.visitSingularFloatField(value: self.saturation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SetEyeColorRequest, rhs: Anki_Vector_ExternalInterface_SetEyeColorRequest) -> Bool {
    if lhs.hue != rhs.hue {return false}
    if lhs.saturation != rhs.saturation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SetEyeColorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetEyeColorResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SetEyeColorResponse, rhs: Anki_Vector_ExternalInterface_SetEyeColorResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SDKInitializationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SDKInitializationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sdk_module_version"),
    2: .standard(proto: "python_version"),
    3: .standard(proto: "python_implementation"),
    4: .standard(proto: "os_version"),
    5: .standard(proto: "cpu_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sdkModuleVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pythonVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pythonImplementation) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.cpuVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sdkModuleVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.sdkModuleVersion, fieldNumber: 1)
    }
    if !self.pythonVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.pythonVersion, fieldNumber: 2)
    }
    if !self.pythonImplementation.isEmpty {
      try visitor.visitSingularStringField(value: self.pythonImplementation, fieldNumber: 3)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 4)
    }
    if !self.cpuVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.cpuVersion, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SDKInitializationRequest, rhs: Anki_Vector_ExternalInterface_SDKInitializationRequest) -> Bool {
    if lhs.sdkModuleVersion != rhs.sdkModuleVersion {return false}
    if lhs.pythonVersion != rhs.pythonVersion {return false}
    if lhs.pythonImplementation != rhs.pythonImplementation {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.cpuVersion != rhs.cpuVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SDKInitializationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SDKInitializationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SDKInitializationResponse, rhs: Anki_Vector_ExternalInterface_SDKInitializationResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
