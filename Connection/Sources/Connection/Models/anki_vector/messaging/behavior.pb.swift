// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: anki_vector/messaging/behavior.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2018 Anki, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License in the file LICENSE.txt or at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Behavior related messages

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Tell the behavior stream to release control from the SDK.
/// The stream may stay alive, but Vector will be allowed to run
/// his normal behaviors.
public struct Anki_Vector_ExternalInterface_ControlRelease {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request control of the behavior system at a given priority.
/// Currently there is only one priority level.
public struct Anki_Vector_ExternalInterface_ControlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Where in the behavior tree the SDK code should be executed.
  public var priority: Anki_Vector_ExternalInterface_ControlRequest.Priority = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Where in the behavior tree the SDK code should be executed.
  public enum Priority: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown priority. Used for versions that don't understand old priority levels.
    case unknown // = 0

    /// Highest priority level. Suppresses most automatic physical reactions, use with caution. 
    case overrideBehaviors // = 10

    /// Normal priority level. Directly under mandatory physical reactions.
    case `default` // = 20

    /// Enable long-running SDK control between script execution.  Not to be used for regular behavior control.
    case reserveControl // = 30
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 10: self = .overrideBehaviors
      case 20: self = .default
      case 30: self = .reserveControl
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .overrideBehaviors: return 10
      case .default: return 20
      case .reserveControl: return 30
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_ControlRequest.Priority: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_ControlRequest.Priority] = [
    .unknown,
    .overrideBehaviors,
    .default,
    .reserveControl,
  ]
}

#endif  // swift(>=4.2)

/// Messages that can be sent to the behavior stream. Explicitly
/// requesting or releasing control.
public struct Anki_Vector_ExternalInterface_BehaviorControlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestType: Anki_Vector_ExternalInterface_BehaviorControlRequest.OneOf_RequestType? = nil

  /// Release control of the behavior system back to Vector.
  public var controlRelease: Anki_Vector_ExternalInterface_ControlRelease {
    get {
      if case .controlRelease(let v)? = requestType {return v}
      return Anki_Vector_ExternalInterface_ControlRelease()
    }
    set {requestType = .controlRelease(newValue)}
  }

  /// Request control of the behavior system for the SDK.
  public var controlRequest: Anki_Vector_ExternalInterface_ControlRequest {
    get {
      if case .controlRequest(let v)? = requestType {return v}
      return Anki_Vector_ExternalInterface_ControlRequest()
    }
    set {requestType = .controlRequest(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_RequestType: Equatable {
    /// Release control of the behavior system back to Vector.
    case controlRelease(Anki_Vector_ExternalInterface_ControlRelease)
    /// Request control of the behavior system for the SDK.
    case controlRequest(Anki_Vector_ExternalInterface_ControlRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Anki_Vector_ExternalInterface_BehaviorControlRequest.OneOf_RequestType, rhs: Anki_Vector_ExternalInterface_BehaviorControlRequest.OneOf_RequestType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.controlRelease, .controlRelease): return {
        guard case .controlRelease(let l) = lhs, case .controlRelease(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.controlRequest, .controlRequest): return {
        guard case .controlRequest(let l) = lhs, case .controlRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The SDK user is now free to run any actions and behaviors they like.
/// Until a ControlLostResponse is received, they are directly in control
/// of Vector's behavior system.
public struct Anki_Vector_ExternalInterface_ControlGrantedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This informs the user that they lost control of the behavior system.
/// All direct actions will be unavailable via the sdk until control is regained.
/// Regaining control can be either through a call to ControlRequest, or
/// can be as a result of conditions passed to the original ControlRequest.
public struct Anki_Vector_ExternalInterface_ControlLostResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The ability to reserve control before/after SDK scripts has been lost.  
/// This control can be regained through another ControlRequest.
public struct Anki_Vector_ExternalInterface_ReservedControlLostResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Responses from the behavior stream.
public struct Anki_Vector_ExternalInterface_BehaviorControlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var responseType: Anki_Vector_ExternalInterface_BehaviorControlResponse.OneOf_ResponseType? = nil

  /// The SDK user is now free to directly control Vector.
  public var controlGrantedResponse: Anki_Vector_ExternalInterface_ControlGrantedResponse {
    get {
      if case .controlGrantedResponse(let v)? = responseType {return v}
      return Anki_Vector_ExternalInterface_ControlGrantedResponse()
    }
    set {responseType = .controlGrantedResponse(newValue)}
  }

  /// Control of the behavior system has been lost to a higher priority behavior.
  public var controlLostEvent: Anki_Vector_ExternalInterface_ControlLostResponse {
    get {
      if case .controlLostEvent(let v)? = responseType {return v}
      return Anki_Vector_ExternalInterface_ControlLostResponse()
    }
    set {responseType = .controlLostEvent(newValue)}
  }

  /// Used by Vector to verify the connection is still alive.
  public var keepAlive: Anki_Vector_ExternalInterface_KeepAlivePing {
    get {
      if case .keepAlive(let v)? = responseType {return v}
      return Anki_Vector_ExternalInterface_KeepAlivePing()
    }
    set {responseType = .keepAlive(newValue)}
  }

  /// Behavior system lock has been lost to another connection
  public var reservedControlLostEvent: Anki_Vector_ExternalInterface_ReservedControlLostResponse {
    get {
      if case .reservedControlLostEvent(let v)? = responseType {return v}
      return Anki_Vector_ExternalInterface_ReservedControlLostResponse()
    }
    set {responseType = .reservedControlLostEvent(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ResponseType: Equatable {
    /// The SDK user is now free to directly control Vector.
    case controlGrantedResponse(Anki_Vector_ExternalInterface_ControlGrantedResponse)
    /// Control of the behavior system has been lost to a higher priority behavior.
    case controlLostEvent(Anki_Vector_ExternalInterface_ControlLostResponse)
    /// Used by Vector to verify the connection is still alive.
    case keepAlive(Anki_Vector_ExternalInterface_KeepAlivePing)
    /// Behavior system lock has been lost to another connection
    case reservedControlLostEvent(Anki_Vector_ExternalInterface_ReservedControlLostResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Anki_Vector_ExternalInterface_BehaviorControlResponse.OneOf_ResponseType, rhs: Anki_Vector_ExternalInterface_BehaviorControlResponse.OneOf_ResponseType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.controlGrantedResponse, .controlGrantedResponse): return {
        guard case .controlGrantedResponse(let l) = lhs, case .controlGrantedResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.controlLostEvent, .controlLostEvent): return {
        guard case .controlLostEvent(let l) = lhs, case .controlLostEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keepAlive, .keepAlive): return {
        guard case .keepAlive(let l) = lhs, case .keepAlive(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reservedControlLostEvent, .reservedControlLostEvent): return {
        guard case .reservedControlLostEvent(let l) = lhs, case .reservedControlLostEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Anki_Vector_ExternalInterface_ControlRelease: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ControlRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ControlRequest.Priority: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_BehaviorControlRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_BehaviorControlRequest.OneOf_RequestType: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ControlGrantedResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ControlLostResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ReservedControlLostResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_BehaviorControlResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_BehaviorControlResponse.OneOf_ResponseType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "Anki.Vector.external_interface"

extension Anki_Vector_ExternalInterface_ControlRelease: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ControlRelease"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ControlRelease, rhs: Anki_Vector_ExternalInterface_ControlRelease) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ControlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ControlRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "priority"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.priority) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.priority != .unknown {
      try visitor.visitSingularEnumField(value: self.priority, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ControlRequest, rhs: Anki_Vector_ExternalInterface_ControlRequest) -> Bool {
    if lhs.priority != rhs.priority {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ControlRequest.Priority: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    10: .same(proto: "OVERRIDE_BEHAVIORS"),
    20: .same(proto: "DEFAULT"),
    30: .same(proto: "RESERVE_CONTROL"),
  ]
}

extension Anki_Vector_ExternalInterface_BehaviorControlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BehaviorControlRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "control_release"),
    2: .standard(proto: "control_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Anki_Vector_ExternalInterface_ControlRelease?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .controlRelease(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .controlRelease(v)
        }
      }()
      case 2: try {
        var v: Anki_Vector_ExternalInterface_ControlRequest?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .controlRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .controlRequest(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.requestType {
    case .controlRelease?: try {
      guard case .controlRelease(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .controlRequest?: try {
      guard case .controlRequest(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_BehaviorControlRequest, rhs: Anki_Vector_ExternalInterface_BehaviorControlRequest) -> Bool {
    if lhs.requestType != rhs.requestType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ControlGrantedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ControlGrantedResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ControlGrantedResponse, rhs: Anki_Vector_ExternalInterface_ControlGrantedResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ControlLostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ControlLostResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ControlLostResponse, rhs: Anki_Vector_ExternalInterface_ControlLostResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ReservedControlLostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReservedControlLostResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ReservedControlLostResponse, rhs: Anki_Vector_ExternalInterface_ReservedControlLostResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_BehaviorControlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BehaviorControlResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "control_granted_response"),
    2: .standard(proto: "control_lost_event"),
    3: .standard(proto: "keep_alive"),
    4: .standard(proto: "reserved_control_lost_event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Anki_Vector_ExternalInterface_ControlGrantedResponse?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .controlGrantedResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .controlGrantedResponse(v)
        }
      }()
      case 2: try {
        var v: Anki_Vector_ExternalInterface_ControlLostResponse?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .controlLostEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .controlLostEvent(v)
        }
      }()
      case 3: try {
        var v: Anki_Vector_ExternalInterface_KeepAlivePing?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .keepAlive(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .keepAlive(v)
        }
      }()
      case 4: try {
        var v: Anki_Vector_ExternalInterface_ReservedControlLostResponse?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .reservedControlLostEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .reservedControlLostEvent(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.responseType {
    case .controlGrantedResponse?: try {
      guard case .controlGrantedResponse(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .controlLostEvent?: try {
      guard case .controlLostEvent(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .keepAlive?: try {
      guard case .keepAlive(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .reservedControlLostEvent?: try {
      guard case .reservedControlLostEvent(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_BehaviorControlResponse, rhs: Anki_Vector_ExternalInterface_BehaviorControlResponse) -> Bool {
    if lhs.responseType != rhs.responseType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
