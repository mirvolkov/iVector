// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: anki_vector/messaging/cube.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2018 Anki, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License in the file LICENSE.txt or at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// External interface for robot <-> app and robot <-> sdk communication

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Anki_Vector_ExternalInterface_ObjectType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case invalidObject // = 0
  case unknownObject // = 1

  ///////////////////////////////////////////////////////////////////////////
  /// Light Cube (a.k.a. Active Block)
  case blockLightcube1 // = 2
  case chargerBasic // = 6
  case firstCustomObjectType // = 15
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalidObject
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalidObject
    case 1: self = .unknownObject
    case 2: self = .blockLightcube1
    case 6: self = .chargerBasic
    case 15: self = .firstCustomObjectType
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalidObject: return 0
    case .unknownObject: return 1
    case .blockLightcube1: return 2
    case .chargerBasic: return 6
    case .firstCustomObjectType: return 15
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_ObjectType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_ObjectType] = [
    .invalidObject,
    .unknownObject,
    .blockLightcube1,
    .chargerBasic,
    .firstCustomObjectType,
  ]
}

#endif  // swift(>=4.2)

public enum Anki_Vector_ExternalInterface_CustomType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case invalidCustomType // = 0
  case customType00 // = 1
  case customType01 // = 2
  case customType02 // = 3
  case customType03 // = 4
  case customType04 // = 5
  case customType05 // = 6
  case customType06 // = 7
  case customType07 // = 8
  case customType08 // = 9
  case customType09 // = 10
  case customType10 // = 11
  case customType11 // = 12
  case customType12 // = 13
  case customType13 // = 14
  case customType14 // = 15
  case customType15 // = 16
  case customType16 // = 17
  case customType17 // = 18
  case customType18 // = 19
  case customType19 // = 20
  public static let count = customType19
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalidCustomType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalidCustomType
    case 1: self = .customType00
    case 2: self = .customType01
    case 3: self = .customType02
    case 4: self = .customType03
    case 5: self = .customType04
    case 6: self = .customType05
    case 7: self = .customType06
    case 8: self = .customType07
    case 9: self = .customType08
    case 10: self = .customType09
    case 11: self = .customType10
    case 12: self = .customType11
    case 13: self = .customType12
    case 14: self = .customType13
    case 15: self = .customType14
    case 16: self = .customType15
    case 17: self = .customType16
    case 18: self = .customType17
    case 19: self = .customType18
    case 20: self = .customType19
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalidCustomType: return 0
    case .customType00: return 1
    case .customType01: return 2
    case .customType02: return 3
    case .customType03: return 4
    case .customType04: return 5
    case .customType05: return 6
    case .customType06: return 7
    case .customType07: return 8
    case .customType08: return 9
    case .customType09: return 10
    case .customType10: return 11
    case .customType11: return 12
    case .customType12: return 13
    case .customType13: return 14
    case .customType14: return 15
    case .customType15: return 16
    case .customType16: return 17
    case .customType17: return 18
    case .customType18: return 19
    case .customType19: return 20
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_CustomType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_CustomType] = [
    .invalidCustomType,
    .customType00,
    .customType01,
    .customType02,
    .customType03,
    .customType04,
    .customType05,
    .customType06,
    .customType07,
    .customType08,
    .customType09,
    .customType10,
    .customType11,
    .customType12,
    .customType13,
    .customType14,
    .customType15,
    .customType16,
    .customType17,
    .customType18,
    .customType19,
  ]
}

#endif  // swift(>=4.2)

/// Note: ObjectFamily is deprecated and will be removed in future releases
public enum Anki_Vector_ExternalInterface_ObjectFamily: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case invalidFamily // = 0
  case unknownFamily // = 1
  case block // = 2
  case lightCube // = 3
  case charger // = 4
  case customObject // = 7
  public static let count = customObject
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalidFamily
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalidFamily
    case 1: self = .unknownFamily
    case 2: self = .block
    case 3: self = .lightCube
    case 4: self = .charger
    case 7: self = .customObject
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalidFamily: return 0
    case .unknownFamily: return 1
    case .block: return 2
    case .lightCube: return 3
    case .charger: return 4
    case .customObject: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_ObjectFamily: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_ObjectFamily] = [
    .invalidFamily,
    .unknownFamily,
    .block,
    .lightCube,
    .charger,
    .customObject,
  ]
}

#endif  // swift(>=4.2)

public enum Anki_Vector_ExternalInterface_UpAxis: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case invalidAxis // = 0
  case xNegative // = 1
  case xPositive // = 2
  case yNegative // = 3
  case yPositive // = 4
  case zNegative // = 5
  case zPositive // = 6
  case numAxes // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalidAxis
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalidAxis
    case 1: self = .xNegative
    case 2: self = .xPositive
    case 3: self = .yNegative
    case 4: self = .yPositive
    case 5: self = .zNegative
    case 6: self = .zPositive
    case 7: self = .numAxes
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalidAxis: return 0
    case .xNegative: return 1
    case .xPositive: return 2
    case .yNegative: return 3
    case .yPositive: return 4
    case .zNegative: return 5
    case .zPositive: return 6
    case .numAxes: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_UpAxis: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_UpAxis] = [
    .invalidAxis,
    .xNegative,
    .xPositive,
    .yNegative,
    .yPositive,
    .zNegative,
    .zPositive,
    .numAxes,
  ]
}

#endif  // swift(>=4.2)

/// Constants associated with the audio feed
public enum Anki_Vector_ExternalInterface_ObjectConstants: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// error value
  case null // = 0

  /// The depth of custom walls used in the engine
  case fixedCustomWallThicknessMm // = 10
  case UNRECOGNIZED(Int)

  public init() {
    self = .null
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .null
    case 10: self = .fixedCustomWallThicknessMm
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .null: return 0
    case .fixedCustomWallThicknessMm: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_ObjectConstants: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_ObjectConstants] = [
    .null,
    .fixedCustomWallThicknessMm,
  ]
}

#endif  // swift(>=4.2)

public enum Anki_Vector_ExternalInterface_CustomObjectMarker: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case customMarkerUnknown // = 0
  case customMarkerCircles2 // = 1
  case customMarkerCircles3 // = 2
  case customMarkerCircles4 // = 3
  case customMarkerCircles5 // = 4
  case customMarkerDiamonds2 // = 5
  case customMarkerDiamonds3 // = 6
  case customMarkerDiamonds4 // = 7
  case customMarkerDiamonds5 // = 8
  case customMarkerHexagons2 // = 9
  case customMarkerHexagons3 // = 10
  case customMarkerHexagons4 // = 11
  case customMarkerHexagons5 // = 12
  case customMarkerTriangles2 // = 13
  case customMarkerTriangles3 // = 14
  case customMarkerTriangles4 // = 15
  case customMarkerTriangles5 // = 16
  public static let customMarkerCount = customMarkerTriangles5
  case UNRECOGNIZED(Int)

  public init() {
    self = .customMarkerUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .customMarkerUnknown
    case 1: self = .customMarkerCircles2
    case 2: self = .customMarkerCircles3
    case 3: self = .customMarkerCircles4
    case 4: self = .customMarkerCircles5
    case 5: self = .customMarkerDiamonds2
    case 6: self = .customMarkerDiamonds3
    case 7: self = .customMarkerDiamonds4
    case 8: self = .customMarkerDiamonds5
    case 9: self = .customMarkerHexagons2
    case 10: self = .customMarkerHexagons3
    case 11: self = .customMarkerHexagons4
    case 12: self = .customMarkerHexagons5
    case 13: self = .customMarkerTriangles2
    case 14: self = .customMarkerTriangles3
    case 15: self = .customMarkerTriangles4
    case 16: self = .customMarkerTriangles5
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .customMarkerUnknown: return 0
    case .customMarkerCircles2: return 1
    case .customMarkerCircles3: return 2
    case .customMarkerCircles4: return 3
    case .customMarkerCircles5: return 4
    case .customMarkerDiamonds2: return 5
    case .customMarkerDiamonds3: return 6
    case .customMarkerDiamonds4: return 7
    case .customMarkerDiamonds5: return 8
    case .customMarkerHexagons2: return 9
    case .customMarkerHexagons3: return 10
    case .customMarkerHexagons4: return 11
    case .customMarkerHexagons5: return 12
    case .customMarkerTriangles2: return 13
    case .customMarkerTriangles3: return 14
    case .customMarkerTriangles4: return 15
    case .customMarkerTriangles5: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_CustomObjectMarker: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_CustomObjectMarker] = [
    .customMarkerUnknown,
    .customMarkerCircles2,
    .customMarkerCircles3,
    .customMarkerCircles4,
    .customMarkerCircles5,
    .customMarkerDiamonds2,
    .customMarkerDiamonds3,
    .customMarkerDiamonds4,
    .customMarkerDiamonds5,
    .customMarkerHexagons2,
    .customMarkerHexagons3,
    .customMarkerHexagons4,
    .customMarkerHexagons5,
    .customMarkerTriangles2,
    .customMarkerTriangles3,
    .customMarkerTriangles4,
    .customMarkerTriangles5,
  ]
}

#endif  // swift(>=4.2)

public enum Anki_Vector_ExternalInterface_CustomObjectDeletionMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case deletionMaskUnknown // = 0
  case deletionMaskFixedCustomObjects // = 1
  case deletionMaskCustomMarkerObjects // = 2
  case deletionMaskArchetypes // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .deletionMaskUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .deletionMaskUnknown
    case 1: self = .deletionMaskFixedCustomObjects
    case 2: self = .deletionMaskCustomMarkerObjects
    case 3: self = .deletionMaskArchetypes
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .deletionMaskUnknown: return 0
    case .deletionMaskFixedCustomObjects: return 1
    case .deletionMaskCustomMarkerObjects: return 2
    case .deletionMaskArchetypes: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_CustomObjectDeletionMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_CustomObjectDeletionMode] = [
    .deletionMaskUnknown,
    .deletionMaskFixedCustomObjects,
    .deletionMaskCustomMarkerObjects,
    .deletionMaskArchetypes,
  ]
}

#endif  // swift(>=4.2)

/// Attempt to connect to a cube. If a cube is currently connected,
/// this will do nothing.
public struct Anki_Vector_ExternalInterface_ConnectCubeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_ConnectCubeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var success: Bool = false

  public var objectID: UInt32 = 0

  public var factoryID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_CubesAvailableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_CubesAvailableResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var factoryIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// Requests a disconnection from the currently connected cube.
public struct Anki_Vector_ExternalInterface_DisconnectCubeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_DisconnectCubeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// Plays the default cube connection animation on the currently
/// connected cube's lights.  This is intended for app level user
/// surfacing of cube connectivity, not for sdk cube light control.
public struct Anki_Vector_ExternalInterface_FlashCubeLightsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_FlashCubeLightsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// Forget the robot's preferred cube. This will cause the robot to
/// connect to the cube with the highest RSSI (signal strength) next
/// time a connection is requested. Saves this preference to disk.
/// The next cube that the robot connects to will become its
/// preferred cube.
public struct Anki_Vector_ExternalInterface_ForgetPreferredCubeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_ForgetPreferredCubeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// Set the robot's preferred cube and save it to disk. The robot
/// will always attempt to connect to this cube if it is available.
/// This is only used in simulation for now.
public struct Anki_Vector_ExternalInterface_SetPreferredCubeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var factoryID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_SetPreferredCubeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// Sets each LED on victor's cube.  Two states are specified
/// designated 'on' and 'off', each with a color, duration,
/// and state transition time
public struct Anki_Vector_ExternalInterface_SetCubeLightsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var objectID: UInt32 = 0

  public var onColor: [UInt32] = []

  public var offColor: [UInt32] = []

  public var onPeriodMs: [UInt32] = []

  public var offPeriodMs: [UInt32] = []

  public var transitionOnPeriodMs: [UInt32] = []

  public var transitionOffPeriodMs: [UInt32] = []

  public var offset: [Int32] = []

  public var relativeToX: Float = 0

  public var relativeToY: Float = 0

  public var rotate: Bool = false

  public var makeRelative: Anki_Vector_ExternalInterface_SetCubeLightsRequest.MakeRelativeMode = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// This is a uint_8 internally.
  public enum MakeRelativeMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case off // = 1
    case byCorner // = 2
    case bySide // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .off
      case 2: self = .byCorner
      case 3: self = .bySide
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .off: return 1
      case .byCorner: return 2
      case .bySide: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Anki_Vector_ExternalInterface_SetCubeLightsRequest.MakeRelativeMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anki_Vector_ExternalInterface_SetCubeLightsRequest.MakeRelativeMode] = [
    .unknown,
    .off,
    .byCorner,
    .bySide,
  ]
}

#endif  // swift(>=4.2)

public struct Anki_Vector_ExternalInterface_SetCubeLightsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_ObjectAvailable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var factoryID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Indicates that a cube has connected or disconnected to the robot.
/// This message will be sent for any connects or disconnects regardless
/// of whether it originated from us or underlying robot behavior.
public struct Anki_Vector_ExternalInterface_ObjectConnectionState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var objectID: UInt32 = 0

  public var factoryID: String = String()

  public var objectType: Anki_Vector_ExternalInterface_ObjectType = .invalidObject

  public var connected: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_ObjectMoved {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: UInt32 = 0

  public var objectID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_ObjectStoppedMoving {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: UInt32 = 0

  public var objectID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_ObjectUpAxisChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: UInt32 = 0

  public var objectID: UInt32 = 0

  public var upAxis: Anki_Vector_ExternalInterface_UpAxis = .invalidAxis

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_ObjectTapped {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: UInt32 = 0

  public var objectID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// RobotObservedObject for signaling that an object
///  with specified ID/Type was seen at a particular location in the image
///  and the world
public struct Anki_Vector_ExternalInterface_RobotObservedObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: UInt32 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  /// ObjectFamily is deprecated. Use ObjectType instead to reason about groupings of objects.
  public var objectFamily: Anki_Vector_ExternalInterface_ObjectFamily {
    get {return _storage._objectFamily}
    set {_uniqueStorage()._objectFamily = newValue}
  }

  public var objectType: Anki_Vector_ExternalInterface_ObjectType {
    get {return _storage._objectType}
    set {_uniqueStorage()._objectType = newValue}
  }

  /// signed to match U2G::PickAndPlaceObject which has the option to have objectID<0
  public var objectID: Int32 {
    get {return _storage._objectID}
    set {_uniqueStorage()._objectID = newValue}
  }

  /// position in image coords
  public var imgRect: Anki_Vector_ExternalInterface_CladRect {
    get {return _storage._imgRect ?? Anki_Vector_ExternalInterface_CladRect()}
    set {_uniqueStorage()._imgRect = newValue}
  }
  /// Returns true if `imgRect` has been explicitly set.
  public var hasImgRect: Bool {return _storage._imgRect != nil}
  /// Clears the value of `imgRect`. Subsequent reads from it will return its default value.
  public mutating func clearImgRect() {_uniqueStorage()._imgRect = nil}

  public var pose: Anki_Vector_ExternalInterface_PoseStruct {
    get {return _storage._pose ?? Anki_Vector_ExternalInterface_PoseStruct()}
    set {_uniqueStorage()._pose = newValue}
  }
  /// Returns true if `pose` has been explicitly set.
  public var hasPose: Bool {return _storage._pose != nil}
  /// Clears the value of `pose`. Subsequent reads from it will return its default value.
  public mutating func clearPose() {_uniqueStorage()._pose = nil}

  /// absolute orienation of top face, iff isActive==true
  public var topFaceOrientationRad: Float {
    get {return _storage._topFaceOrientationRad}
    set {_uniqueStorage()._topFaceOrientationRad = newValue}
  }

  public var isActive: UInt32 {
    get {return _storage._isActive}
    set {_uniqueStorage()._isActive = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Indicates that a the connection subscribed through ConnectCube has
/// been lost.
public struct Anki_Vector_ExternalInterface_CubeConnectionLost {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Deletes all custom objects matching a given deletion mode.
public struct Anki_Vector_ExternalInterface_DeleteCustomObjectsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: Anki_Vector_ExternalInterface_CustomObjectDeletionMode = .deletionMaskUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_DeleteCustomObjectsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// Creates a CustomObject at the specific pose with no markers associated with it
/// Since this object has no markers with which to be observed, it will remain in the
/// specified pose as an obstacle forever (or until deleted with a deletion message above)
public struct Anki_Vector_ExternalInterface_CreateFixedCustomObjectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pose: Anki_Vector_ExternalInterface_PoseStruct {
    get {return _pose ?? Anki_Vector_ExternalInterface_PoseStruct()}
    set {_pose = newValue}
  }
  /// Returns true if `pose` has been explicitly set.
  public var hasPose: Bool {return self._pose != nil}
  /// Clears the value of `pose`. Subsequent reads from it will return its default value.
  public mutating func clearPose() {self._pose = nil}

  public var xSizeMm: Float = 0

  public var ySizeMm: Float = 0

  public var zSizeMm: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pose: Anki_Vector_ExternalInterface_PoseStruct? = nil
}

public struct Anki_Vector_ExternalInterface_CreateFixedCustomObjectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var objectID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

/// Defines a custom object of the given size with the given markers centered on each side
/// If isUnique=true, there is guaranteed to be no more than one object of this type present in the world
public struct Anki_Vector_ExternalInterface_CustomBoxDefinition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var markerFront: Anki_Vector_ExternalInterface_CustomObjectMarker = .customMarkerUnknown

  public var markerBack: Anki_Vector_ExternalInterface_CustomObjectMarker = .customMarkerUnknown

  public var markerTop: Anki_Vector_ExternalInterface_CustomObjectMarker = .customMarkerUnknown

  public var markerBottom: Anki_Vector_ExternalInterface_CustomObjectMarker = .customMarkerUnknown

  public var markerLeft: Anki_Vector_ExternalInterface_CustomObjectMarker = .customMarkerUnknown

  public var markerRight: Anki_Vector_ExternalInterface_CustomObjectMarker = .customMarkerUnknown

  public var xSizeMm: Float = 0

  public var ySizeMm: Float = 0

  public var zSizeMm: Float = 0

  public var markerWidthMm: Float = 0

  public var markerHeightMm: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Defines a custom cube of the given size. The cube will have the same marker centered on all faces.
/// If isUnique=true, there is guaranteed to be no more than one cube of this type present in the world at a time.
public struct Anki_Vector_ExternalInterface_CustomCubeDefinition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var marker: Anki_Vector_ExternalInterface_CustomObjectMarker = .customMarkerUnknown

  public var sizeMm: Float = 0

  public var markerWidthMm: Float = 0

  public var markerHeightMm: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Defines a custom wall of the given height and width, with the same marker centered on both sides (front and back).
/// The wall's thickness is assumed to be 1cm (and thus there are no markers on its left, right, top, or bottom)
/// If isUnique=true, there is guaranteed to be no more than one wall of this type present in the world at a time.
public struct Anki_Vector_ExternalInterface_CustomWallDefinition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var marker: Anki_Vector_ExternalInterface_CustomObjectMarker = .customMarkerUnknown

  public var widthMm: Float = 0

  public var heightMm: Float = 0

  public var markerWidthMm: Float = 0

  public var markerHeightMm: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Anki_Vector_ExternalInterface_DefineCustomObjectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var customType: Anki_Vector_ExternalInterface_CustomType = .invalidCustomType

  public var isUnique: Bool = false

  public var customObjectDefinition: Anki_Vector_ExternalInterface_DefineCustomObjectRequest.OneOf_CustomObjectDefinition? = nil

  public var customBox: Anki_Vector_ExternalInterface_CustomBoxDefinition {
    get {
      if case .customBox(let v)? = customObjectDefinition {return v}
      return Anki_Vector_ExternalInterface_CustomBoxDefinition()
    }
    set {customObjectDefinition = .customBox(newValue)}
  }

  public var customCube: Anki_Vector_ExternalInterface_CustomCubeDefinition {
    get {
      if case .customCube(let v)? = customObjectDefinition {return v}
      return Anki_Vector_ExternalInterface_CustomCubeDefinition()
    }
    set {customObjectDefinition = .customCube(newValue)}
  }

  public var customWall: Anki_Vector_ExternalInterface_CustomWallDefinition {
    get {
      if case .customWall(let v)? = customObjectDefinition {return v}
      return Anki_Vector_ExternalInterface_CustomWallDefinition()
    }
    set {customObjectDefinition = .customWall(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_CustomObjectDefinition: Equatable {
    case customBox(Anki_Vector_ExternalInterface_CustomBoxDefinition)
    case customCube(Anki_Vector_ExternalInterface_CustomCubeDefinition)
    case customWall(Anki_Vector_ExternalInterface_CustomWallDefinition)

  #if !swift(>=4.1)
    public static func ==(lhs: Anki_Vector_ExternalInterface_DefineCustomObjectRequest.OneOf_CustomObjectDefinition, rhs: Anki_Vector_ExternalInterface_DefineCustomObjectRequest.OneOf_CustomObjectDefinition) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.customBox, .customBox): return {
        guard case .customBox(let l) = lhs, case .customBox(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.customCube, .customCube): return {
        guard case .customCube(let l) = lhs, case .customCube(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.customWall, .customWall): return {
        guard case .customWall(let l) = lhs, case .customWall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Anki_Vector_ExternalInterface_DefineCustomObjectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Anki_Vector_ExternalInterface_ResponseStatus {
    get {return _status ?? Anki_Vector_ExternalInterface_ResponseStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Anki_Vector_ExternalInterface_ResponseStatus? = nil
}

public struct Anki_Vector_ExternalInterface_ObjectEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var objectEventType: Anki_Vector_ExternalInterface_ObjectEvent.OneOf_ObjectEventType? = nil

  public var objectAvailable: Anki_Vector_ExternalInterface_ObjectAvailable {
    get {
      if case .objectAvailable(let v)? = objectEventType {return v}
      return Anki_Vector_ExternalInterface_ObjectAvailable()
    }
    set {objectEventType = .objectAvailable(newValue)}
  }

  public var objectConnectionState: Anki_Vector_ExternalInterface_ObjectConnectionState {
    get {
      if case .objectConnectionState(let v)? = objectEventType {return v}
      return Anki_Vector_ExternalInterface_ObjectConnectionState()
    }
    set {objectEventType = .objectConnectionState(newValue)}
  }

  public var objectMoved: Anki_Vector_ExternalInterface_ObjectMoved {
    get {
      if case .objectMoved(let v)? = objectEventType {return v}
      return Anki_Vector_ExternalInterface_ObjectMoved()
    }
    set {objectEventType = .objectMoved(newValue)}
  }

  public var objectStoppedMoving: Anki_Vector_ExternalInterface_ObjectStoppedMoving {
    get {
      if case .objectStoppedMoving(let v)? = objectEventType {return v}
      return Anki_Vector_ExternalInterface_ObjectStoppedMoving()
    }
    set {objectEventType = .objectStoppedMoving(newValue)}
  }

  public var objectUpAxisChanged: Anki_Vector_ExternalInterface_ObjectUpAxisChanged {
    get {
      if case .objectUpAxisChanged(let v)? = objectEventType {return v}
      return Anki_Vector_ExternalInterface_ObjectUpAxisChanged()
    }
    set {objectEventType = .objectUpAxisChanged(newValue)}
  }

  public var objectTapped: Anki_Vector_ExternalInterface_ObjectTapped {
    get {
      if case .objectTapped(let v)? = objectEventType {return v}
      return Anki_Vector_ExternalInterface_ObjectTapped()
    }
    set {objectEventType = .objectTapped(newValue)}
  }

  public var robotObservedObject: Anki_Vector_ExternalInterface_RobotObservedObject {
    get {
      if case .robotObservedObject(let v)? = objectEventType {return v}
      return Anki_Vector_ExternalInterface_RobotObservedObject()
    }
    set {objectEventType = .robotObservedObject(newValue)}
  }

  public var cubeConnectionLost: Anki_Vector_ExternalInterface_CubeConnectionLost {
    get {
      if case .cubeConnectionLost(let v)? = objectEventType {return v}
      return Anki_Vector_ExternalInterface_CubeConnectionLost()
    }
    set {objectEventType = .cubeConnectionLost(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ObjectEventType: Equatable {
    case objectAvailable(Anki_Vector_ExternalInterface_ObjectAvailable)
    case objectConnectionState(Anki_Vector_ExternalInterface_ObjectConnectionState)
    case objectMoved(Anki_Vector_ExternalInterface_ObjectMoved)
    case objectStoppedMoving(Anki_Vector_ExternalInterface_ObjectStoppedMoving)
    case objectUpAxisChanged(Anki_Vector_ExternalInterface_ObjectUpAxisChanged)
    case objectTapped(Anki_Vector_ExternalInterface_ObjectTapped)
    case robotObservedObject(Anki_Vector_ExternalInterface_RobotObservedObject)
    case cubeConnectionLost(Anki_Vector_ExternalInterface_CubeConnectionLost)

  #if !swift(>=4.1)
    public static func ==(lhs: Anki_Vector_ExternalInterface_ObjectEvent.OneOf_ObjectEventType, rhs: Anki_Vector_ExternalInterface_ObjectEvent.OneOf_ObjectEventType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.objectAvailable, .objectAvailable): return {
        guard case .objectAvailable(let l) = lhs, case .objectAvailable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.objectConnectionState, .objectConnectionState): return {
        guard case .objectConnectionState(let l) = lhs, case .objectConnectionState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.objectMoved, .objectMoved): return {
        guard case .objectMoved(let l) = lhs, case .objectMoved(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.objectStoppedMoving, .objectStoppedMoving): return {
        guard case .objectStoppedMoving(let l) = lhs, case .objectStoppedMoving(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.objectUpAxisChanged, .objectUpAxisChanged): return {
        guard case .objectUpAxisChanged(let l) = lhs, case .objectUpAxisChanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.objectTapped, .objectTapped): return {
        guard case .objectTapped(let l) = lhs, case .objectTapped(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.robotObservedObject, .robotObservedObject): return {
        guard case .robotObservedObject(let l) = lhs, case .robotObservedObject(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cubeConnectionLost, .cubeConnectionLost): return {
        guard case .cubeConnectionLost(let l) = lhs, case .cubeConnectionLost(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Anki_Vector_ExternalInterface_ObjectType: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CustomType: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ObjectFamily: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_UpAxis: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ObjectConstants: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CustomObjectMarker: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CustomObjectDeletionMode: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ConnectCubeRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ConnectCubeResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CubesAvailableRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CubesAvailableResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DisconnectCubeRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DisconnectCubeResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_FlashCubeLightsRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_FlashCubeLightsResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ForgetPreferredCubeRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ForgetPreferredCubeResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SetPreferredCubeRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SetPreferredCubeResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SetCubeLightsRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SetCubeLightsRequest.MakeRelativeMode: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_SetCubeLightsResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ObjectAvailable: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ObjectConnectionState: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ObjectMoved: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ObjectStoppedMoving: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ObjectUpAxisChanged: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ObjectTapped: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_RobotObservedObject: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CubeConnectionLost: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DeleteCustomObjectsRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DeleteCustomObjectsResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CreateFixedCustomObjectRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CreateFixedCustomObjectResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CustomBoxDefinition: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CustomCubeDefinition: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_CustomWallDefinition: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DefineCustomObjectRequest: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DefineCustomObjectRequest.OneOf_CustomObjectDefinition: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_DefineCustomObjectResponse: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ObjectEvent: @unchecked Sendable {}
extension Anki_Vector_ExternalInterface_ObjectEvent.OneOf_ObjectEventType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "Anki.Vector.external_interface"

extension Anki_Vector_ExternalInterface_ObjectType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_OBJECT"),
    1: .same(proto: "UNKNOWN_OBJECT"),
    2: .same(proto: "BLOCK_LIGHTCUBE1"),
    6: .same(proto: "CHARGER_BASIC"),
    15: .same(proto: "FIRST_CUSTOM_OBJECT_TYPE"),
  ]
}

extension Anki_Vector_ExternalInterface_CustomType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_CUSTOM_TYPE"),
    1: .same(proto: "CUSTOM_TYPE_00"),
    2: .same(proto: "CUSTOM_TYPE_01"),
    3: .same(proto: "CUSTOM_TYPE_02"),
    4: .same(proto: "CUSTOM_TYPE_03"),
    5: .same(proto: "CUSTOM_TYPE_04"),
    6: .same(proto: "CUSTOM_TYPE_05"),
    7: .same(proto: "CUSTOM_TYPE_06"),
    8: .same(proto: "CUSTOM_TYPE_07"),
    9: .same(proto: "CUSTOM_TYPE_08"),
    10: .same(proto: "CUSTOM_TYPE_09"),
    11: .same(proto: "CUSTOM_TYPE_10"),
    12: .same(proto: "CUSTOM_TYPE_11"),
    13: .same(proto: "CUSTOM_TYPE_12"),
    14: .same(proto: "CUSTOM_TYPE_13"),
    15: .same(proto: "CUSTOM_TYPE_14"),
    16: .same(proto: "CUSTOM_TYPE_15"),
    17: .same(proto: "CUSTOM_TYPE_16"),
    18: .same(proto: "CUSTOM_TYPE_17"),
    19: .same(proto: "CUSTOM_TYPE_18"),
    20: .aliased(proto: "CUSTOM_TYPE_19", aliases: ["CUSTOM_TYPE_COUNT"]),
  ]
}

extension Anki_Vector_ExternalInterface_ObjectFamily: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_FAMILY"),
    1: .same(proto: "UNKNOWN_FAMILY"),
    2: .same(proto: "BLOCK"),
    3: .same(proto: "LIGHT_CUBE"),
    4: .same(proto: "CHARGER"),
    7: .aliased(proto: "CUSTOM_OBJECT", aliases: ["OBJECT_FAMILY_COUNT"]),
  ]
}

extension Anki_Vector_ExternalInterface_UpAxis: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_AXIS"),
    1: .same(proto: "X_NEGATIVE"),
    2: .same(proto: "X_POSITIVE"),
    3: .same(proto: "Y_NEGATIVE"),
    4: .same(proto: "Y_POSITIVE"),
    5: .same(proto: "Z_NEGATIVE"),
    6: .same(proto: "Z_POSITIVE"),
    7: .same(proto: "NUM_AXES"),
  ]
}

extension Anki_Vector_ExternalInterface_ObjectConstants: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OBJECT_CONSTANTS_NULL"),
    10: .same(proto: "FIXED_CUSTOM_WALL_THICKNESS_MM"),
  ]
}

extension Anki_Vector_ExternalInterface_CustomObjectMarker: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CUSTOM_MARKER_UNKNOWN"),
    1: .same(proto: "CUSTOM_MARKER_CIRCLES_2"),
    2: .same(proto: "CUSTOM_MARKER_CIRCLES_3"),
    3: .same(proto: "CUSTOM_MARKER_CIRCLES_4"),
    4: .same(proto: "CUSTOM_MARKER_CIRCLES_5"),
    5: .same(proto: "CUSTOM_MARKER_DIAMONDS_2"),
    6: .same(proto: "CUSTOM_MARKER_DIAMONDS_3"),
    7: .same(proto: "CUSTOM_MARKER_DIAMONDS_4"),
    8: .same(proto: "CUSTOM_MARKER_DIAMONDS_5"),
    9: .same(proto: "CUSTOM_MARKER_HEXAGONS_2"),
    10: .same(proto: "CUSTOM_MARKER_HEXAGONS_3"),
    11: .same(proto: "CUSTOM_MARKER_HEXAGONS_4"),
    12: .same(proto: "CUSTOM_MARKER_HEXAGONS_5"),
    13: .same(proto: "CUSTOM_MARKER_TRIANGLES_2"),
    14: .same(proto: "CUSTOM_MARKER_TRIANGLES_3"),
    15: .same(proto: "CUSTOM_MARKER_TRIANGLES_4"),
    16: .aliased(proto: "CUSTOM_MARKER_TRIANGLES_5", aliases: ["CUSTOM_MARKER_COUNT"]),
  ]
}

extension Anki_Vector_ExternalInterface_CustomObjectDeletionMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DELETION_MASK_UNKNOWN"),
    1: .same(proto: "DELETION_MASK_FIXED_CUSTOM_OBJECTS"),
    2: .same(proto: "DELETION_MASK_CUSTOM_MARKER_OBJECTS"),
    3: .same(proto: "DELETION_MASK_ARCHETYPES"),
  ]
}

extension Anki_Vector_ExternalInterface_ConnectCubeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectCubeRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ConnectCubeRequest, rhs: Anki_Vector_ExternalInterface_ConnectCubeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ConnectCubeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectCubeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "success"),
    3: .standard(proto: "object_id"),
    4: .standard(proto: "factory_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.objectID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.factoryID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if self.objectID != 0 {
      try visitor.visitSingularUInt32Field(value: self.objectID, fieldNumber: 3)
    }
    if !self.factoryID.isEmpty {
      try visitor.visitSingularStringField(value: self.factoryID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ConnectCubeResponse, rhs: Anki_Vector_ExternalInterface_ConnectCubeResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.success != rhs.success {return false}
    if lhs.objectID != rhs.objectID {return false}
    if lhs.factoryID != rhs.factoryID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CubesAvailableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CubesAvailableRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CubesAvailableRequest, rhs: Anki_Vector_ExternalInterface_CubesAvailableRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CubesAvailableResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CubesAvailableResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "factory_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.factoryIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.factoryIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.factoryIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CubesAvailableResponse, rhs: Anki_Vector_ExternalInterface_CubesAvailableResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.factoryIds != rhs.factoryIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DisconnectCubeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisconnectCubeRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DisconnectCubeRequest, rhs: Anki_Vector_ExternalInterface_DisconnectCubeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DisconnectCubeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisconnectCubeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DisconnectCubeResponse, rhs: Anki_Vector_ExternalInterface_DisconnectCubeResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_FlashCubeLightsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FlashCubeLightsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_FlashCubeLightsRequest, rhs: Anki_Vector_ExternalInterface_FlashCubeLightsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_FlashCubeLightsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FlashCubeLightsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_FlashCubeLightsResponse, rhs: Anki_Vector_ExternalInterface_FlashCubeLightsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ForgetPreferredCubeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForgetPreferredCubeRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ForgetPreferredCubeRequest, rhs: Anki_Vector_ExternalInterface_ForgetPreferredCubeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ForgetPreferredCubeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForgetPreferredCubeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ForgetPreferredCubeResponse, rhs: Anki_Vector_ExternalInterface_ForgetPreferredCubeResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SetPreferredCubeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetPreferredCubeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "factory_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.factoryID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.factoryID.isEmpty {
      try visitor.visitSingularStringField(value: self.factoryID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SetPreferredCubeRequest, rhs: Anki_Vector_ExternalInterface_SetPreferredCubeRequest) -> Bool {
    if lhs.factoryID != rhs.factoryID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SetPreferredCubeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetPreferredCubeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SetPreferredCubeResponse, rhs: Anki_Vector_ExternalInterface_SetPreferredCubeResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SetCubeLightsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetCubeLightsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .standard(proto: "on_color"),
    3: .standard(proto: "off_color"),
    4: .standard(proto: "on_period_ms"),
    5: .standard(proto: "off_period_ms"),
    6: .standard(proto: "transition_on_period_ms"),
    7: .standard(proto: "transition_off_period_ms"),
    8: .same(proto: "offset"),
    9: .standard(proto: "relative_to_x"),
    10: .standard(proto: "relative_to_y"),
    11: .same(proto: "rotate"),
    12: .standard(proto: "make_relative"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.objectID) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.onColor) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.offColor) }()
      case 4: try { try decoder.decodeRepeatedUInt32Field(value: &self.onPeriodMs) }()
      case 5: try { try decoder.decodeRepeatedUInt32Field(value: &self.offPeriodMs) }()
      case 6: try { try decoder.decodeRepeatedUInt32Field(value: &self.transitionOnPeriodMs) }()
      case 7: try { try decoder.decodeRepeatedUInt32Field(value: &self.transitionOffPeriodMs) }()
      case 8: try { try decoder.decodeRepeatedInt32Field(value: &self.offset) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.relativeToX) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.relativeToY) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.rotate) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.makeRelative) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.objectID != 0 {
      try visitor.visitSingularUInt32Field(value: self.objectID, fieldNumber: 1)
    }
    if !self.onColor.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.onColor, fieldNumber: 2)
    }
    if !self.offColor.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.offColor, fieldNumber: 3)
    }
    if !self.onPeriodMs.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.onPeriodMs, fieldNumber: 4)
    }
    if !self.offPeriodMs.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.offPeriodMs, fieldNumber: 5)
    }
    if !self.transitionOnPeriodMs.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.transitionOnPeriodMs, fieldNumber: 6)
    }
    if !self.transitionOffPeriodMs.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.transitionOffPeriodMs, fieldNumber: 7)
    }
    if !self.offset.isEmpty {
      try visitor.visitPackedInt32Field(value: self.offset, fieldNumber: 8)
    }
    if self.relativeToX != 0 {
      try visitor.visitSingularFloatField(value: self.relativeToX, fieldNumber: 9)
    }
    if self.relativeToY != 0 {
      try visitor.visitSingularFloatField(value: self.relativeToY, fieldNumber: 10)
    }
    if self.rotate != false {
      try visitor.visitSingularBoolField(value: self.rotate, fieldNumber: 11)
    }
    if self.makeRelative != .unknown {
      try visitor.visitSingularEnumField(value: self.makeRelative, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SetCubeLightsRequest, rhs: Anki_Vector_ExternalInterface_SetCubeLightsRequest) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.onColor != rhs.onColor {return false}
    if lhs.offColor != rhs.offColor {return false}
    if lhs.onPeriodMs != rhs.onPeriodMs {return false}
    if lhs.offPeriodMs != rhs.offPeriodMs {return false}
    if lhs.transitionOnPeriodMs != rhs.transitionOnPeriodMs {return false}
    if lhs.transitionOffPeriodMs != rhs.transitionOffPeriodMs {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.relativeToX != rhs.relativeToX {return false}
    if lhs.relativeToY != rhs.relativeToY {return false}
    if lhs.rotate != rhs.rotate {return false}
    if lhs.makeRelative != rhs.makeRelative {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_SetCubeLightsRequest.MakeRelativeMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "OFF"),
    2: .same(proto: "BY_CORNER"),
    3: .same(proto: "BY_SIDE"),
  ]
}

extension Anki_Vector_ExternalInterface_SetCubeLightsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetCubeLightsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_SetCubeLightsResponse, rhs: Anki_Vector_ExternalInterface_SetCubeLightsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ObjectAvailable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectAvailable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "factory_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.factoryID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.factoryID.isEmpty {
      try visitor.visitSingularStringField(value: self.factoryID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ObjectAvailable, rhs: Anki_Vector_ExternalInterface_ObjectAvailable) -> Bool {
    if lhs.factoryID != rhs.factoryID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ObjectConnectionState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectConnectionState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .standard(proto: "factory_id"),
    3: .standard(proto: "object_type"),
    4: .same(proto: "connected"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.factoryID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.objectType) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.connected) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.objectID != 0 {
      try visitor.visitSingularUInt32Field(value: self.objectID, fieldNumber: 1)
    }
    if !self.factoryID.isEmpty {
      try visitor.visitSingularStringField(value: self.factoryID, fieldNumber: 2)
    }
    if self.objectType != .invalidObject {
      try visitor.visitSingularEnumField(value: self.objectType, fieldNumber: 3)
    }
    if self.connected != false {
      try visitor.visitSingularBoolField(value: self.connected, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ObjectConnectionState, rhs: Anki_Vector_ExternalInterface_ObjectConnectionState) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.factoryID != rhs.factoryID {return false}
    if lhs.objectType != rhs.objectType {return false}
    if lhs.connected != rhs.connected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ObjectMoved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectMoved"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "object_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.objectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestamp, fieldNumber: 1)
    }
    if self.objectID != 0 {
      try visitor.visitSingularUInt32Field(value: self.objectID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ObjectMoved, rhs: Anki_Vector_ExternalInterface_ObjectMoved) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.objectID != rhs.objectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ObjectStoppedMoving: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectStoppedMoving"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "object_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.objectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestamp, fieldNumber: 1)
    }
    if self.objectID != 0 {
      try visitor.visitSingularUInt32Field(value: self.objectID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ObjectStoppedMoving, rhs: Anki_Vector_ExternalInterface_ObjectStoppedMoving) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.objectID != rhs.objectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ObjectUpAxisChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectUpAxisChanged"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "object_id"),
    3: .standard(proto: "up_axis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.objectID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.upAxis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestamp, fieldNumber: 1)
    }
    if self.objectID != 0 {
      try visitor.visitSingularUInt32Field(value: self.objectID, fieldNumber: 2)
    }
    if self.upAxis != .invalidAxis {
      try visitor.visitSingularEnumField(value: self.upAxis, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ObjectUpAxisChanged, rhs: Anki_Vector_ExternalInterface_ObjectUpAxisChanged) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.objectID != rhs.objectID {return false}
    if lhs.upAxis != rhs.upAxis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ObjectTapped: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectTapped"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "object_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.objectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestamp, fieldNumber: 1)
    }
    if self.objectID != 0 {
      try visitor.visitSingularUInt32Field(value: self.objectID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ObjectTapped, rhs: Anki_Vector_ExternalInterface_ObjectTapped) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.objectID != rhs.objectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_RobotObservedObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotObservedObject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "object_family"),
    3: .standard(proto: "object_type"),
    4: .standard(proto: "object_id"),
    5: .standard(proto: "img_rect"),
    6: .same(proto: "pose"),
    7: .standard(proto: "top_face_orientation_rad"),
    8: .standard(proto: "is_active"),
  ]

  fileprivate class _StorageClass {
    var _timestamp: UInt32 = 0
    var _objectFamily: Anki_Vector_ExternalInterface_ObjectFamily = .invalidFamily
    var _objectType: Anki_Vector_ExternalInterface_ObjectType = .invalidObject
    var _objectID: Int32 = 0
    var _imgRect: Anki_Vector_ExternalInterface_CladRect? = nil
    var _pose: Anki_Vector_ExternalInterface_PoseStruct? = nil
    var _topFaceOrientationRad: Float = 0
    var _isActive: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timestamp = source._timestamp
      _objectFamily = source._objectFamily
      _objectType = source._objectType
      _objectID = source._objectID
      _imgRect = source._imgRect
      _pose = source._pose
      _topFaceOrientationRad = source._topFaceOrientationRad
      _isActive = source._isActive
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._timestamp) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._objectFamily) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._objectType) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._objectID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._imgRect) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._pose) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._topFaceOrientationRad) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._isActive) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._timestamp != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._timestamp, fieldNumber: 1)
      }
      if _storage._objectFamily != .invalidFamily {
        try visitor.visitSingularEnumField(value: _storage._objectFamily, fieldNumber: 2)
      }
      if _storage._objectType != .invalidObject {
        try visitor.visitSingularEnumField(value: _storage._objectType, fieldNumber: 3)
      }
      if _storage._objectID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._objectID, fieldNumber: 4)
      }
      try { if let v = _storage._imgRect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._pose {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._topFaceOrientationRad != 0 {
        try visitor.visitSingularFloatField(value: _storage._topFaceOrientationRad, fieldNumber: 7)
      }
      if _storage._isActive != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._isActive, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_RobotObservedObject, rhs: Anki_Vector_ExternalInterface_RobotObservedObject) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._objectFamily != rhs_storage._objectFamily {return false}
        if _storage._objectType != rhs_storage._objectType {return false}
        if _storage._objectID != rhs_storage._objectID {return false}
        if _storage._imgRect != rhs_storage._imgRect {return false}
        if _storage._pose != rhs_storage._pose {return false}
        if _storage._topFaceOrientationRad != rhs_storage._topFaceOrientationRad {return false}
        if _storage._isActive != rhs_storage._isActive {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CubeConnectionLost: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CubeConnectionLost"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CubeConnectionLost, rhs: Anki_Vector_ExternalInterface_CubeConnectionLost) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DeleteCustomObjectsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteCustomObjectsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .deletionMaskUnknown {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DeleteCustomObjectsRequest, rhs: Anki_Vector_ExternalInterface_DeleteCustomObjectsRequest) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DeleteCustomObjectsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteCustomObjectsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DeleteCustomObjectsResponse, rhs: Anki_Vector_ExternalInterface_DeleteCustomObjectsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CreateFixedCustomObjectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateFixedCustomObjectRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pose"),
    2: .standard(proto: "x_size_mm"),
    3: .standard(proto: "y_size_mm"),
    4: .standard(proto: "z_size_mm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pose) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.xSizeMm) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.ySizeMm) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.zSizeMm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pose {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.xSizeMm != 0 {
      try visitor.visitSingularFloatField(value: self.xSizeMm, fieldNumber: 2)
    }
    if self.ySizeMm != 0 {
      try visitor.visitSingularFloatField(value: self.ySizeMm, fieldNumber: 3)
    }
    if self.zSizeMm != 0 {
      try visitor.visitSingularFloatField(value: self.zSizeMm, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CreateFixedCustomObjectRequest, rhs: Anki_Vector_ExternalInterface_CreateFixedCustomObjectRequest) -> Bool {
    if lhs._pose != rhs._pose {return false}
    if lhs.xSizeMm != rhs.xSizeMm {return false}
    if lhs.ySizeMm != rhs.ySizeMm {return false}
    if lhs.zSizeMm != rhs.zSizeMm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CreateFixedCustomObjectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateFixedCustomObjectResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "object_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.objectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.objectID != 0 {
      try visitor.visitSingularUInt32Field(value: self.objectID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CreateFixedCustomObjectResponse, rhs: Anki_Vector_ExternalInterface_CreateFixedCustomObjectResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.objectID != rhs.objectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CustomBoxDefinition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CustomBoxDefinition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "marker_front"),
    2: .standard(proto: "marker_back"),
    3: .standard(proto: "marker_top"),
    4: .standard(proto: "marker_bottom"),
    5: .standard(proto: "marker_left"),
    6: .standard(proto: "marker_right"),
    7: .standard(proto: "x_size_mm"),
    8: .standard(proto: "y_size_mm"),
    9: .standard(proto: "z_size_mm"),
    10: .standard(proto: "marker_width_mm"),
    11: .standard(proto: "marker_height_mm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.markerFront) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.markerBack) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.markerTop) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.markerBottom) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.markerLeft) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.markerRight) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.xSizeMm) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.ySizeMm) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.zSizeMm) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.markerWidthMm) }()
      case 11: try { try decoder.decodeSingularFloatField(value: &self.markerHeightMm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.markerFront != .customMarkerUnknown {
      try visitor.visitSingularEnumField(value: self.markerFront, fieldNumber: 1)
    }
    if self.markerBack != .customMarkerUnknown {
      try visitor.visitSingularEnumField(value: self.markerBack, fieldNumber: 2)
    }
    if self.markerTop != .customMarkerUnknown {
      try visitor.visitSingularEnumField(value: self.markerTop, fieldNumber: 3)
    }
    if self.markerBottom != .customMarkerUnknown {
      try visitor.visitSingularEnumField(value: self.markerBottom, fieldNumber: 4)
    }
    if self.markerLeft != .customMarkerUnknown {
      try visitor.visitSingularEnumField(value: self.markerLeft, fieldNumber: 5)
    }
    if self.markerRight != .customMarkerUnknown {
      try visitor.visitSingularEnumField(value: self.markerRight, fieldNumber: 6)
    }
    if self.xSizeMm != 0 {
      try visitor.visitSingularFloatField(value: self.xSizeMm, fieldNumber: 7)
    }
    if self.ySizeMm != 0 {
      try visitor.visitSingularFloatField(value: self.ySizeMm, fieldNumber: 8)
    }
    if self.zSizeMm != 0 {
      try visitor.visitSingularFloatField(value: self.zSizeMm, fieldNumber: 9)
    }
    if self.markerWidthMm != 0 {
      try visitor.visitSingularFloatField(value: self.markerWidthMm, fieldNumber: 10)
    }
    if self.markerHeightMm != 0 {
      try visitor.visitSingularFloatField(value: self.markerHeightMm, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CustomBoxDefinition, rhs: Anki_Vector_ExternalInterface_CustomBoxDefinition) -> Bool {
    if lhs.markerFront != rhs.markerFront {return false}
    if lhs.markerBack != rhs.markerBack {return false}
    if lhs.markerTop != rhs.markerTop {return false}
    if lhs.markerBottom != rhs.markerBottom {return false}
    if lhs.markerLeft != rhs.markerLeft {return false}
    if lhs.markerRight != rhs.markerRight {return false}
    if lhs.xSizeMm != rhs.xSizeMm {return false}
    if lhs.ySizeMm != rhs.ySizeMm {return false}
    if lhs.zSizeMm != rhs.zSizeMm {return false}
    if lhs.markerWidthMm != rhs.markerWidthMm {return false}
    if lhs.markerHeightMm != rhs.markerHeightMm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CustomCubeDefinition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CustomCubeDefinition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "marker"),
    2: .standard(proto: "size_mm"),
    3: .standard(proto: "marker_width_mm"),
    4: .standard(proto: "marker_height_mm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.marker) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.sizeMm) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.markerWidthMm) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.markerHeightMm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.marker != .customMarkerUnknown {
      try visitor.visitSingularEnumField(value: self.marker, fieldNumber: 1)
    }
    if self.sizeMm != 0 {
      try visitor.visitSingularFloatField(value: self.sizeMm, fieldNumber: 2)
    }
    if self.markerWidthMm != 0 {
      try visitor.visitSingularFloatField(value: self.markerWidthMm, fieldNumber: 3)
    }
    if self.markerHeightMm != 0 {
      try visitor.visitSingularFloatField(value: self.markerHeightMm, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CustomCubeDefinition, rhs: Anki_Vector_ExternalInterface_CustomCubeDefinition) -> Bool {
    if lhs.marker != rhs.marker {return false}
    if lhs.sizeMm != rhs.sizeMm {return false}
    if lhs.markerWidthMm != rhs.markerWidthMm {return false}
    if lhs.markerHeightMm != rhs.markerHeightMm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_CustomWallDefinition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CustomWallDefinition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "marker"),
    2: .standard(proto: "width_mm"),
    3: .standard(proto: "height_mm"),
    4: .standard(proto: "marker_width_mm"),
    5: .standard(proto: "marker_height_mm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.marker) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.widthMm) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.heightMm) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.markerWidthMm) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.markerHeightMm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.marker != .customMarkerUnknown {
      try visitor.visitSingularEnumField(value: self.marker, fieldNumber: 1)
    }
    if self.widthMm != 0 {
      try visitor.visitSingularFloatField(value: self.widthMm, fieldNumber: 2)
    }
    if self.heightMm != 0 {
      try visitor.visitSingularFloatField(value: self.heightMm, fieldNumber: 3)
    }
    if self.markerWidthMm != 0 {
      try visitor.visitSingularFloatField(value: self.markerWidthMm, fieldNumber: 4)
    }
    if self.markerHeightMm != 0 {
      try visitor.visitSingularFloatField(value: self.markerHeightMm, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_CustomWallDefinition, rhs: Anki_Vector_ExternalInterface_CustomWallDefinition) -> Bool {
    if lhs.marker != rhs.marker {return false}
    if lhs.widthMm != rhs.widthMm {return false}
    if lhs.heightMm != rhs.heightMm {return false}
    if lhs.markerWidthMm != rhs.markerWidthMm {return false}
    if lhs.markerHeightMm != rhs.markerHeightMm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DefineCustomObjectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DefineCustomObjectRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "custom_type"),
    2: .standard(proto: "is_unique"),
    3: .standard(proto: "custom_box"),
    4: .standard(proto: "custom_cube"),
    5: .standard(proto: "custom_wall"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.customType) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isUnique) }()
      case 3: try {
        var v: Anki_Vector_ExternalInterface_CustomBoxDefinition?
        var hadOneofValue = false
        if let current = self.customObjectDefinition {
          hadOneofValue = true
          if case .customBox(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.customObjectDefinition = .customBox(v)
        }
      }()
      case 4: try {
        var v: Anki_Vector_ExternalInterface_CustomCubeDefinition?
        var hadOneofValue = false
        if let current = self.customObjectDefinition {
          hadOneofValue = true
          if case .customCube(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.customObjectDefinition = .customCube(v)
        }
      }()
      case 5: try {
        var v: Anki_Vector_ExternalInterface_CustomWallDefinition?
        var hadOneofValue = false
        if let current = self.customObjectDefinition {
          hadOneofValue = true
          if case .customWall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.customObjectDefinition = .customWall(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.customType != .invalidCustomType {
      try visitor.visitSingularEnumField(value: self.customType, fieldNumber: 1)
    }
    if self.isUnique != false {
      try visitor.visitSingularBoolField(value: self.isUnique, fieldNumber: 2)
    }
    switch self.customObjectDefinition {
    case .customBox?: try {
      guard case .customBox(let v)? = self.customObjectDefinition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .customCube?: try {
      guard case .customCube(let v)? = self.customObjectDefinition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .customWall?: try {
      guard case .customWall(let v)? = self.customObjectDefinition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DefineCustomObjectRequest, rhs: Anki_Vector_ExternalInterface_DefineCustomObjectRequest) -> Bool {
    if lhs.customType != rhs.customType {return false}
    if lhs.isUnique != rhs.isUnique {return false}
    if lhs.customObjectDefinition != rhs.customObjectDefinition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_DefineCustomObjectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DefineCustomObjectResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_DefineCustomObjectResponse, rhs: Anki_Vector_ExternalInterface_DefineCustomObjectResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anki_Vector_ExternalInterface_ObjectEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_available"),
    2: .standard(proto: "object_connection_state"),
    3: .standard(proto: "object_moved"),
    4: .standard(proto: "object_stopped_moving"),
    5: .standard(proto: "object_up_axis_changed"),
    6: .standard(proto: "object_tapped"),
    7: .standard(proto: "robot_observed_object"),
    8: .standard(proto: "cube_connection_lost"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Anki_Vector_ExternalInterface_ObjectAvailable?
        var hadOneofValue = false
        if let current = self.objectEventType {
          hadOneofValue = true
          if case .objectAvailable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.objectEventType = .objectAvailable(v)
        }
      }()
      case 2: try {
        var v: Anki_Vector_ExternalInterface_ObjectConnectionState?
        var hadOneofValue = false
        if let current = self.objectEventType {
          hadOneofValue = true
          if case .objectConnectionState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.objectEventType = .objectConnectionState(v)
        }
      }()
      case 3: try {
        var v: Anki_Vector_ExternalInterface_ObjectMoved?
        var hadOneofValue = false
        if let current = self.objectEventType {
          hadOneofValue = true
          if case .objectMoved(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.objectEventType = .objectMoved(v)
        }
      }()
      case 4: try {
        var v: Anki_Vector_ExternalInterface_ObjectStoppedMoving?
        var hadOneofValue = false
        if let current = self.objectEventType {
          hadOneofValue = true
          if case .objectStoppedMoving(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.objectEventType = .objectStoppedMoving(v)
        }
      }()
      case 5: try {
        var v: Anki_Vector_ExternalInterface_ObjectUpAxisChanged?
        var hadOneofValue = false
        if let current = self.objectEventType {
          hadOneofValue = true
          if case .objectUpAxisChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.objectEventType = .objectUpAxisChanged(v)
        }
      }()
      case 6: try {
        var v: Anki_Vector_ExternalInterface_ObjectTapped?
        var hadOneofValue = false
        if let current = self.objectEventType {
          hadOneofValue = true
          if case .objectTapped(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.objectEventType = .objectTapped(v)
        }
      }()
      case 7: try {
        var v: Anki_Vector_ExternalInterface_RobotObservedObject?
        var hadOneofValue = false
        if let current = self.objectEventType {
          hadOneofValue = true
          if case .robotObservedObject(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.objectEventType = .robotObservedObject(v)
        }
      }()
      case 8: try {
        var v: Anki_Vector_ExternalInterface_CubeConnectionLost?
        var hadOneofValue = false
        if let current = self.objectEventType {
          hadOneofValue = true
          if case .cubeConnectionLost(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.objectEventType = .cubeConnectionLost(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.objectEventType {
    case .objectAvailable?: try {
      guard case .objectAvailable(let v)? = self.objectEventType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .objectConnectionState?: try {
      guard case .objectConnectionState(let v)? = self.objectEventType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .objectMoved?: try {
      guard case .objectMoved(let v)? = self.objectEventType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .objectStoppedMoving?: try {
      guard case .objectStoppedMoving(let v)? = self.objectEventType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .objectUpAxisChanged?: try {
      guard case .objectUpAxisChanged(let v)? = self.objectEventType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .objectTapped?: try {
      guard case .objectTapped(let v)? = self.objectEventType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .robotObservedObject?: try {
      guard case .robotObservedObject(let v)? = self.objectEventType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .cubeConnectionLost?: try {
      guard case .cubeConnectionLost(let v)? = self.objectEventType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anki_Vector_ExternalInterface_ObjectEvent, rhs: Anki_Vector_ExternalInterface_ObjectEvent) -> Bool {
    if lhs.objectEventType != rhs.objectEventType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
